# Dictionary of Terms and Notes

### UDEMY
  - https://www.udemy.com/course/the-complete-javascript-course/learn/lecture/22628657#overview
### Ruby on Rails
  - https://www.railstutorial.org/book
### Odin Project
  - https://www.theodinproject.com/paths/foundations/courses/foundations#javascript-basics 

## Lecture Resources

  * Objects  https://github.com/andydlindsay/sep16-2024/tree/main/w01d03
  * Callbacks  https://github.com/FrancisBourgouin/lectures-web-ft-sep16-2024/tree/main/w1d4
    - https://vimeo.com/1015946338/633db77663
    - https://github.com/andydlindsay/flex-sep23-2024/tree/main/m01w02-2
  * TDD with Mocha & Chai
    - https://web.compass.lighthouselabs.ca/activities/101/lectures/14872
  * Asynchronus Control Flow https://github.com/andydlindsay/sep16-2024/tree/main/w02d02
  * Networking and HTTP
    - Part 1: https://vimeo.com/1012900013/6c1c4c8c17
    - Part 2: https://vimeo.com/1012899907/ee980ed2ae?share=copy 
  * Promises https://vimeo.com/1023023372/115ef98d8a?share=copy
    - My cohort: https://github.com/letsandeepio/2024-09-23-Sep-23-Flex/tree/main/w5-promises
    - video : https://vimeo.com/1023314847/4fbf0205a6?share=copy
  * Web Servers https://vimeo.com/960857186/ea63eff652
    - code repo https://github.com/andydlindsay/flex-may13-2024/tree/main/m03w06-1
  * CRUD: https://github.com/letsandeepio/2024-09-23-Sep-23-Flex/tree/main/w6-CRUD_with_express
    - https://docs.google.com/presentation/d/1AEk4UVsEeggDgSzO0vKO2caWPAtDqwr-4t7vw7-GKFY/edit#slide=id.p
  * CSS
    - lecture notes here good css info and example pikachu
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m3w8
  * DOM and JQUERY
    - https://github.com/letsandeepio/2024-09-23-Sep-23-Flex/tree/main/w8-client-side-javascript-jquery
  * AJAX
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m3w9/AJAXLecture
  * Responsive Design and SASS
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m4w10/sassLecture
  * SQL
    - https://web.compass.lighthouselabs.ca/p/web-flex-2/activities/220/lectures/15297?workbook_id=web-flex-v2-m05w11
  * Database Design
    - https://web.compass.lighthouselabs.ca/activities/975/lectures/15326
  * SQL from our Apps
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m5w12/sqlAppsLecture
  * Team Git Workflow Breakout
    - https://web.compass.lighthouselabs.ca/activities/4076/lectures/15347
    - https://gist.github.com/andydlindsay/c0dd09a93d603b64a6fec7addd3a92e5
  - Midterm Lecture:
    - other cohort: https://web.compass.lighthouselabs.ca/p/web-flex-2/activities/4589/lectures/14606?workbook_id=web-flex-v2-m05w13
    - my cohort: https://web.compass.lighthouselabs.ca/p/web-flex-2/activities/4589/lectures/15383?workbook_id=web-flex-v2-m05w13
  * React Lecture JSX and props:
    - https://web.compass.lighthouselabs.ca/p/web-flex-2/activities/2523/lectures/15511
  * What is React State?
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m7w17/ReactState
  * React State Management and Immutable Update Patterns
    - https://web.compass.lighthouselabs.ca/activities/2673/lectures/15552
  * React Custom Hooks
    - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m7w18/CustomHooksLecture
  * Data Fetching & Other Side Effects
    - https://web.compass.lighthouselabs.ca/p/web-flex-2/activities/2675/lectures/15585
  * Class Based Components Lecture
   - https://github.com/senhorgomes/lectures-flex-sep-23/tree/main/m7w19/ClassesLecture
    
    

<!-- ## Projects

# Midterm Project
  - Group - find out later this week. when group is formed it starts
  - Lectures
  - have a database and work with postgres
  - have good plan and map out project. break it into smaller pieces
  - weeks 14 and 15
  - back on the 6th
  - Jan 6th to 18th midterm
  - presentation on 18th of january
  - 2 weeeks for midterms
  - project manager - mentor
  - list requirements of app
  - projects
    - Wiki map 6/10: 
    - quiz app:5/10 can make it themed, as long as filling requirements
    - story creator:4/10 one person starts a story, another adds to it
    - decision maker
    - passwordKeeper one of the easiest. can use encrpytion method in tinyapp
    - smart todo list 8 or 9/10
    - resource wall 5/10
    - buy/sell listing website 5/10
    - Schoodle: more modern doodle app (event scheduling)
    - food pick up ordering: 9/10 for 1 restaurant
      - 2 views 1 admin 1 customer
      - admin edit the website
      - sms component
    - hardest to easiest
      - hardest: smart todo list. food pickup ordering is most work because you are working on 2 views. and the sms component which takes a lot of time
      - easiest: probably schoodle

      wiki map harder than decision maker
      most difficult part is chat integration
      can pick the same projects 
      no limit to how many people pick the same project
      - byran did wiki maps and 2 other groups in his cohort
      - pokemon go uses leaflet and it is free
      - use free APIs
    - create user stories - keep it simple
    - if you submit MVP you will pass
    - user login/registration - dont need to do this. have users created in database. do not waste time on this
      - set up fake login route
      - fake users built into app. dont need to register new users
    - 5 minutes for presentation only
    - figma.com wireframe template - know what colours and schemes you are going to use
    - vertically - each memember works on own feature - feature based (project is feature based)
    - horizonatlly - each dev focus on front end or back end, or database
  - everyone on group same node version so no complications
    - nvm 16. nvm install 16. nvm alias default 16
  - whole group should have same database
  - instead of app using express router so they dont all exist in server.js
  - Demo of app
    - 5 minutes
    - intro team
    - present app and features
    - why the feature was implemented
    - challenges faced
    - tech stack used
  - 2 weeks for midterm
    - spend at least 1-3 days only on planning. no code touched just plan
    - user stoires, erd, routes, wire frame
    - then start coding
    - coding for a week or week and a half
    - 4 days debugging and practice
    - within last 4 days dont add new featurtes
      - dont present buggy app

# Final Project
  - can use midterm skeleton code

## LightBnB
  - nvm use 20
  - PostgreSQL peterheyboer pass lighthouse
    - LightBnB Instructions:
      - cd /home/peterheyboer/lighthouse/LightBnB
      - ```sudo service postgresql start``` peter heyboer lighthouse every time
      - sudo -u postgres psql -d lightbnb
      - \i migrations/01_schema.sql
  -   Run the app ```npm run local``` and view it at ```localhost:3000```
  - connect to database and run local host from another terminal
  1. nvm use 20
  2. ```sudo service postgresql start``` peter heyboer lighthouse
  3. ```psql -U development -d lightbnb``` logs into lightbnb database as development user

- PostgreSQL peterheyboer pass lighthouse
    - LightBnB Instructions:
      - cd /home/peterheyboer/lighthouse/LightBnB
      - ```sudo service postgresql start``` peter heyboer lighthouse every time
      - sudo -u postgres psql -d lightbnb
      - \i migrations/01_schema.sql

  - Connecting to psql
    - psql -U your_username -d your_database -h your_server_ip -p 5432 -W

  - ruby exercises
    - BUNDLE_GEMFILE=~/lighthouse/ar-exercises/Gemfile bundle exec ruby exercises/exercise_1.rb

   -->
## Test Topics
 - Test 1:
    - Count numbers in Array
    - Sum numbers of Array - can use ```.reduce```
    - Find the mean of an Array
    - Find the minimum Value of an Array
    - Find the maximum value of an Array
    - Find the range of an Array - can use ```.sort```
    - Find the meadian value of an Array
    - Find the Mode of an Array
    - Find the Standard Deviation of an Array
    - Review of test 1: will use ```.sort``` on test 2
  - Test 2:
    - All of test 1 topics
    - Functions as Objects
    - Comparisons (how to tell if two arrays are equal)
    - Callbacks
  - Test 3:
    - Test 1 and 2 topics
    - The test consists of 5 questions, primarily centered around general JavaScript (not Express or the browser-related topics we've covered recently). You can expect to engage with arrays, objects, algorithms, and recursive functions, with a strong emphasis on logical reasoning.
    - Review: Intro to Async, Music Library, Week 3, Array and object manipulation, Callbacks
  - Test 4:
    - asynchronus control flow using callbacks
    - one stretch question on promises
  - Test 5: SQL
    - ability to craft SQL SELECT statements
    
  ### For testing use node version 10 (nvm use 10) regularly use node version 20 (nvm use 20)


## Technical Interviews
  - Ask clarifying questions
    - What kind of values are there?
    - How big is the size of the input?
    - How is the input stored?
  - Topics: First Interview
    - JavaScript fundamentals
    - Coding best practices and readability
    - Async vs. Sync code execution
    - Writing functions
    - Using loops and objects
 - Topics: Second Interview
    - ERD
    - Table relationships
    - Using loops and objects
## Recipe
  - Clarify Question
  - Define Inputs
  - Define Outputs
  - Prcoessing and Logic
  - Break code down into small steps - incremental solutions
      - Write out pseudocode for each step

## Example Technical Interview Question
  - Video: https://vimeo.com/1024956107/7ec592c4a7?share=copy
  - Example: https://github.com/jatanassian/flex-september-2024/tree/main/breakout_tech-interview

# Shortcuts and Cheatsheets

## VSCode Shortcuts
  https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf

## Git Shortcuts
  https://education.github.com/git-cheat-sheet-education.pdf

## Git Cloning and Commiting
  - Go to directory
  - ```git init``` to create new git repository
  - Make sure git is initalized (be careful for nested Git Repositories)
  - ```git clone <SSH URL>``` always use SSH
  - ```git status```
  - ```git add <file name>```
  - ```git commit -m "Commit Message"```
  - ```git push```
  - Double check branches and origin

  - git checkout -b branch-name 
    - to create new branch and switch to it
  - git push origin branch-name
    - push changes from new branch

  ### For Lighthouse Labs Testing
 - Git clone
  - Go to directory
  - Get token from Compass
  - ```npm run start-exam [exam token]```

## Markdown shortcuts
 https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet

## Javascript Cheatsheet
 https://htmlcheatsheet.com/js/

## Vim CheatSheet
 http://www.viemu.com/vi-vim-cheat-sheet.gif

## HTML Cheatsheet
 https://web.stanford.edu/group/csp/cs21/htmlcheatsheet.pdf

## Crow foot notation cheet sheet
  https://www.vivekmchawla.com/erd-crows-foot-relationship-symbols-cheat-sheet/

## React Cheatsheet
  https://devhints.io/react

## Ruby Cheatsheet
  https://github.com/ThibaultJanBeyer/cheatsheets/blob/master/Ruby-Cheatsheet.md
  https://dev.to/ericchapman/my-beloved-ruby-cheat-sheet-208o
  


## Terminology
### Variables
  - var - function scoped or globally scoped
  - let - block scoped (inside loop or conditionals)
  - const - block scoped

  ### Node.js
    - Javascript runtime built on CHrome's V8 Javascript engine
    - Core API provides EventEmitter class that is the basis for event driven patterns

  ### Scoping
   - Scoping: How variables are organized and accessed
   - Scope: space or environment in where a variable is declared
   - Lexical scoping: controlled by placement of functions and blocks in the code
    - Global - variable declared outside any function or block. Accessible anywhere
    - Function - variables declared within a function are scoped to that function. Accessible only within function (local scope)
    - Block - variable confined to the block {} in which they are declared such as within 'it' or 'for'. Accessible within block
      - let and const block scoped
      - functions are blocked scoped when in strict mode

  - ```var``` : block scopes dont apply. function scoped
  - Scope chain (order in which functions are written in the code) VS Call stack (order in which functions are called)
    - scope chain has nothing to do with order in which functions are called
    - scope chain is a one way street. a scope will never have access to variables of an inner scope (can only look up not down)

  - You can have repeated variable names if they are not in the same scope
  - can have different functions with same parameter names



## Dot Notation and Bracket Notation
  - 2 ways to access or modify the properties of objects
  - Dot notation:
    - access or set properties on object
    - dot and key to access value
    - cant use if property has special characters
  - Bracket Notation:
    -  can use any string, character, or number as property names
    - brackets have expression that evaluate to a value
  - Make more notes on differences


### Hoisting
  - move variable and function declarations to the top of their scope during compile phase
    - Variable accessible/usable in code before declared
  - Temporal dead zone (TDZ):
    - time between the beginning of a block of scope (function OR let/const declaration) and actual declaration of the variable within that block
    - let and const: initial value: uninitialized
    - function expression and arrows: let or const, not useable before declared (TDZ)
    - never use arrow function with a method

## ```this``` variable
  - special variable created for every function
  - takes the value of the owner of the function
  - points to the owner of the function
  - method - has ```this``` property
  - simple function call (undefined)
    - strict mode can use
  - arrow functions: dont have own ```this``` keyword (parent function)
  - ```this``` does not point to the function itself

## Strict Mode
  - to enable: at top of page write ```"use strict"```
  - eliminates silent errors (assign a value to undeclared variable with throw error)
  - disallows duplicate Parameters
  - prevents ```this``` from defaulting
  - disallows certain syntax (reserved words)
  - throws error for invalid useage
  - no ```with``` statements

## Fs.readfile
  - read contents of file asynchronously
  - belongs to fs (file system) module which provides functions for interacting with file system
    - reading, writing, modifying files
  - Aysnchronus: program continues executing while while is being read, avoiding blocking the mian thread
    - ideal for I/O operations in a non blocking way
  - Callback based: function accepts a callback that is invoked once the file reading operation is complete
    - ```fs.readFile(path, encoding, callback);```
  ```js
  const fs = require('fs');

  fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading the file:', err);
    } else {
      console.log('File content:', data);
    }
  });
  ```





## module.exports
  - used to export and import variables, functions, objects from one file to another
  - can add key/value pairs like any object. Values will be available in the file that requires them
  - module.exports is a special object that needs a require statement that will run all the code in the specified file

## Pseudocode 
```js    
Loop from 100 to 200:
  Let num = the current step in the loop
  If num % 3 is equal to 0 and num % 4 is equal to 0:
    Print "LoopyLighthouse"
  Else if num % 3 is equal to 0:
    Print "Loopy"
  Else if num % 4 is equal to 0:
    Print "Lighthouse"
  Otherwise
    Print num
  End if
End loop
```

 # How we write a function
```js  
  function myFunction(a, b, c) {
    return a + b + c; }
```

# Object Iteration
 - Properties rea Key-Value pairs associated with an Object
```js
const person = {
  name: 'Alice',
  age: 30,
  isStudent: false
};
Object Constructor:

javascript
Copy code
const person = new Object();
person.name = 'Alice';
person.age = 30;
person.isStudent = false;
```
 * ### For Loop C-Style
  - To iterate over the objects in an array
```js
  function printArrayElements(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}

// Example usage:
const exampleArray = [1, 2, 3, 4, 5];
printArrayElements(exampleArray); 
```


  * ## For...in
  - OBJECTS
  - Iterates over keys (property names)
  - Iterates through ARRAYS AND OBJECTS
  - Loop through keys of object (indexes)
  - Use when you need to access property keys
```js  
const person = {
    name: 'Alice',
    age: 25,
    city: 'New York'
};

for (const key in person) {
    console.log(`${key}: ${person[key]}`);
}
```
```js
const dog = {
  faveToy: 'squeaky ball',
  breed: 'labrador',
  name: 'dioji',
};

for (const key in dog) {
  console.log('value', dog[key]);
}
```

 * ## For...of
  - ARRAYS
  - Iterates over values
  - Iterates through: arrays, strings, maps, sets. NOT OBJECTS
  - Use when you want to iterate over values of an ARRAY
    - if object is not iterable (plain object) ```TypeError```
  - Returns VALUES not keys
```js
const greeting = 'Hello';

for (const char of greeting) {
    console.log(char);
}
```
  - Output: 
```js
H
e
l
l
o
```

 * ### forEach
  - Execute provided function once for each element in the array
  - Can iterate over elements without needining to manage the loop counter
```js
array.forEach(callback(currentValue, index, array) {
    // Code to execute for each element
});
```

  - ```Infinity``` is highest number in JS
  - ```!``` Logical NOT operator
    - Inverts truthiness of a value


# Array Methods
  * ```.push()``` adds new element to end of array and returns new length of array
```js
let arr = [1, 2, 3];
arr.push(4); // arr is now [1, 2, 3, 4]
```
  * ```.pop()``` removes last element from array and returns that element
```js
let arr = [1, 2, 3];
let lastElement = arr.pop(); // lastElement is 3, arr is now [1, 2]
```
  * ```.shift()``` removes first element from array and returns that element
```js
let arr = [1, 2, 3];
let firstElement = arr.shift(); // firstElement is 1, arr is now [2, 3]
```
  * ```.unshift()``` adds element to begining of array and returns new length of array
```js
let arr = [2, 3];
arr.unshift(1); // arr is now [1, 2, 3]
```
  * ```.splice()``` remove or replace element and add new element in its place
```js
let arr = [1, 2, 3, 4];
arr.splice(1, 2, 'a', 'b'); // arr is now [1, 'a', 'b', 4]
```
  * ```.forEach``` executes provided function once for each element in array
```js
let arr = [1, 2, 3];
arr.forEach((num) => {
    console.log(num); // prints 1, 2, 3
});
```
  * ```.map()``` creates new array with results of calling a function on every element in the calling array
```js
let arr = [1, 2, 3];
let doubled = arr.map(num => num * 2); // doubled is [2, 4, 6]
```
  * ```.filter()``` creates new array with all elements that pass the test implemented by provided function
```js
let arr = [1, 2, 3, 4];
let evens = arr.filter(num => num % 2 === 0); // evens is [2, 4]
```
  * ```.reduce()``` reduce array to a single value. results in a single output value
    - Example: the sum of the elements of an array
    - Reduces an array to primitives
```js    
  let arr = [1, 2, 3];
  let sum = arr.reduce((acc, num) => acc + num, 0); // sum is 
```

  * ```.find()``` returns value of first element of array that satisfies test function
```js
let arr = [1, 2, 3];
let found = arr.find(num => num > 1); // found is 2
```
  * ```.included()``` check if array has a certain value. Returns true or false
```js
let arr = [1, 2, 3];
let hasTwo = arr.includes(2); // hasTwo is true
```
  * ```.sort()``` sorts elements of array. Returns sorted array
    - Very useful
    - modified original array and returns reference to same array
    - uses lexigraphical sorting
    - Sorts in asccending order
    - Can use this to find the Range
    - Single digits will sort correctly, big digits will not -lexigraphical sorting
    - deceding order use ```array.reverse```
    - Accepts function reference
      - Sorted based on relationship between each pair of elements a and b
      - <0, >0, or 0
    
```js
let arr = [3, 1, 2];
arr.sort(); // arr is now [1, 2, 3]

```
```js
    let numbers = [4, 2, 5, 1, 3];

// Sort in ascending order
numbers.sort((a, b) => a - b);
console.log(numbers); // Output: [1, 2, 3, 4, 5]

// Sort in descending order
numbers.sort((a, b) => b - a);
console.log(numbers); // Output: [5, 4, 3, 2, 1]
```

  * ```.join()``` joins element of array intro a string, separated by specified operator
```js
let arr = ['Hello', 'World'];
let str = arr.join(' '); // str is "Hello World"
```
  * ```.reverse()``` reverses elements of array
```js
let arr = [1, 2, 3];
arr.reverse(); // arr is now [3, 2, 1]
```



### Function for Sum of 2 numbers with assertion test
```js
// FUNCTION IMPLEMENTATION
const sum = function (a, b) {
  return a + b;
};

// TEST CODE
console.assert(sum(1, 2) === 3);
console.assert(sum(1, 20) === 3); // bad / incorrect assertion, and we see it fail!
```

* 
* ParseINT - turns string to number
* ParseFloat - for decimals

* Console.assert
  - Static method write an error message to the console if assertion is false. If true nothing happens

* Split
  - ```.split(/\s+/)``` divides string into an array, where each element corresponds to a part of the string that was separated by whitespace.
  - Example:
```js
  
    const trimmedName = "John Doe Smith";
const nameParts = trimmedName.split(/\s+/);
console.log(nameParts); // ["John", "Doe", "Smith"]

```


# Callbacks
  - A function we pass to another function as arguments
```js  
function greet(name, callback) {
    console.log(`Hello, ${name}!`);
    callback();
}

function sayGoodbye() {
    console.log("Goodbye!");
}

// Passing sayGoodbye as a callback to greet
greet("Alice", sayGoodbye);
```

* Slice process arguments
* Arrays

## Data types
  - Primitive: String, number, boolean, undefined, null, symbol, (bigInt)
  - 7 Fundamental types of Javascript: 6 above plus Objects
  - Reference: Objects, Arrays, Functions
  - Data Types are Primitives OR objects
  - Dot syntax works on nested objects
  - function that doesnt have a return: it will be undefined
  - Primitive types dont have properties
  - Primitive types have corresponding Objects
  - Objects are called REFERENCE TYPES
  - primitives stored in call stack
  - variables hold memory address
  - objects stored in heap
  - const is immutable: only true for primitive values but not reference values

## Objects
  - Key/value pairs
  - The key in an object is always a string
  - In arrays, use index to access a value
  - Use key to access value
  - Array is type of object
  - Object is like a table with 2 columns
  - Object is a bundle of information known as ```state```
  - When property's value is a function, it is called a method
  - Behaviour: what the method does
  - ```this``` refers to the object that the method was called on

```js
  const myObj = {
  firstName: 'Lorem',
  lastName: 'Ipsum'
};

// we have two options for accessing values
// dot syntax
console.log(myObj.firstName); // Lorem

// square bracket syntax
console.log(myObj['lastName']); // Ipsum
```
- Functions inside Objects
  - Objects are key/value pairs. Functions are values. You can store functions inside of an object
  - Reference other properties in an object by using 'this'
  - ```this``` works within context of object
  - ```this``` DOES NOT work with arrow functions
    - reference to the oject where ```this``` is used
```js
const myObj = {
  firstName: 'Lorem',
  sayHello: function () {
    console.log('hello');
  }
};

myObj.sayHello(); // hello
console.log(myObj); // { firstName: 'Lorem', sayHello: [Function: sayHello] }
```  
  - Reference other properties in an object by using 'this'
```js
const myObj = {
  firstName: 'Lorem',
  lastName: 'Ipsum',
  sayFullName: function () {
    console.log(`My full name is ${this.firstName} ${this.lastName}`);
  }
};

myObj.sayFullName(); // My full name is Lorem Ipsum
```
 - Object iteration with ```for...in```
    - Iterate through object's keys. CANT use ```for...of```
```js
const obj = { a: 1, b: 2, c: 3 };

for (const key in obj) {
  // we can use the key to access the value
  const value = obj[key];
}
```

* ## Object Oriented Programming
  - Programming paradigm where we use objects to encapsulate data and behaviour
    - these are properties of the object
    - we do this to reduce duplicated code and to break up code into sensibly divided -
    - OOP by itsself does not require the use of classes
  - A class is a blueprint from which instances of objects can be created
  - Classes have data in the form of calue properties and behaviour in the form of methods
  - classes can inherit behaviour from other classes using the ```extends``` keyword
  - Subclasses can override methods that are inherited in their superclass
  - Javascript gives us ```get``` and ```set``` keywords to define methods that are data getters and setters 
  - OOP software development paradigm
  - popular way to solve code organization, re-use and modularity
  - Javascript is not strictly OO in the way that Java or Ruby are
  - Functional programming is an alternative paradigm
  - classes are most popular way to perform OO
    - Javascripts object system is based on ```prototypes``` not classes
    - Classes added in ES6
  - In OOP classes are templates that we use to create instances of objects
    - A class describes what the object is going to be and we can create new objects using the class
  - To declare a new class use the ```class``` keyword
    - To create a new object from a class use the ```new``` keyword
  - ```constructor``` special kind of method for setting default values for any new objects properties
  - Class pattern allows us to DRY up code by defining the default state and behaviours in one place
  - Classes promote code modularity
    - define a blueprint once and create multiple instances from it
    - each instance inherits properties and methods from the class
      - reduces redundancy
    - Instead of deining multiple object literals with same methods and properties, a class is defined once, and instances created from the class will all share the same method implementation but can maintain different states.
    - The encapsulation of related data and behaviours within a class structure promotes modularity and makes code cleaner and easier to maintain ***
    - OO bundles together state and logic into an object that can be represented into a single variable 
  - Getters: method that retrieves a property value
```js
  const person = {
    firstName: 'John',
    lastName: 'Doe',
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
};

console.log(person.fullName); // Output: "John Doe"

```
  - Setters: allows you to set a property value
```js
const person = {
    firstName: 'John',
    lastName: 'Doe',
    set fullName(name) {
        const parts = name.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = 'Jane Smith';
console.log(person.firstName); // Output: "Jane"
console.log(person.lastName);  // Output: "Smith"
```
- Full example:
```js
class Person {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    }

    set fullName(name) {
        const parts = name.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
}

const person = new Person('John', 'Doe');
console.log(person.fullName); // Output: "John Doe"
person.fullName = 'Jane Smith';
console.log(person.firstName); // Output: "Jane"
```
  - public vs private setters
  - add information about super keyword
  - Dependency Injection: passing an object the things  it needs rather than having the object access them itself. makes code more modular and testable
  - Single Responsibility Principle - change in one part wont affect other unrelated parts of our app

* ## Inheritance
  - Duplication problem
    - Two classes that share the same behaviour and state information
  - Inheritance: build a new class based on an existing class
    - Remove duplicatoin by moving shared code from two classes into another class
  - ```extends``` superclass vs subclass






* ## Data Structures
* ## Dot Syntax
* ## fs readfile


* ## Function
    Implement a function with example

* ## Arrow Functions
  - Concise way to write functions
  - Annymous by nature
```js
 const add = (a, b) => {
    return a + b;
};
```
```js
const add = (a, b) => a + b; // Implicit return

```
```js
const square = x => x * x; // No parentheses needed for single parameter
```
  - No binding of ```this```
    - Arrow functions dont have their own binding of ```this```
    - Useful for callbacks
```js
function Counter() {
    this.count = 0;

    // Using a regular function would bind 'this' to the function itself
    setInterval(function() {
        this.count++; // 'this' is not the Counter instance
        console.log(this.count);
    }, 1000);
}

const counter = new Counter(); // NaN is printed

// Using an arrow function preserves 'this'
function Counter() {
    this.count = 0;

    setInterval(() => {
        this.count++; // 'this' refers to the Counter instance
        console.log(this.count);
    }, 1000);
}

const counter = new Counter(); // 1, 2, 3, ...

```
  - Use Cases:
    - Callbacks: commonly used in array methods ```.map()```, ```.filter()```, and ```.reduce()```
    - ```.reduce``` callback function on each element of the array, in order, passing return value from calculation on previous element
  - Arrow functions do not have their own ```arguments``` object
  - Not suitable for methods
  - Cannot be used as constructor function

* ## Template Literals
  - Enclosed with backticks ```(`)```
  - Can have multi-line strings
  - String interpolation - dynamic strings
  - Tagged templates

* # Recursion
  - Technique where a function calls itself in order to solve a problem
  - Key components:
    - Base Case: Condition that stops recursion. Without this, function calls itself indefinitely leading to stack overflow
    - Recursive Case: The function calls itsself with modified arguments that bring it closer to the base case 
```js
function factorial(n) {
  // Base case: factorial of 0 is 1
  if (n === 0) {
    return 1;
  }
  // Recursive case: n! = n * (n - 1)!
  return n * factorial(n - 1);
}

console.log(factorial(5)); // Output: 120
```
  - Tail Recursion:
    - Recursive call is the last operation in the function
    - Javascript does not have built in tail call optimization

* ## Command Line Arguments
  - Accessible via the ```process``` object: ```process.argv```
  - Allow you to pass information to your Node.js scripts
  - ```.slice``` to take out parts of the array into a new object array
  - Example:
 ```js 
  const args = process.argv.slice(2); //slice out first 2 command line arguments
const sum = function(numbers) { //create function called sum
  let total = 0;
  for (let i = 0; i < numbers.length; i++) { //loop through array
    total += Number(numbers[i]); // turn string to number
  }
  return total;
};
console.log("Sum: ", sum(args));
```
- Example 2, Tail: use slice to return everything exept first item (head) of array
```js
const tail = function(array) {
  return array.slice(1);
};
```


* ## Linting
 -  Eslint - analyze code for potential errors and enforces standard code
 - Debuggin procedures
 - How to decipher an error message

* ## Higher Order Functions
  - Functions that can take other functions as arguments or return functions as their output
  - Accepting functions as arguments
  - Can return another function

* ## Annonymous Functions
  - Functions that are defined without a name. Used as arguments to other functions, for callbacks
  or when defining functions that will not be reused
  - Useful when function only needed once or for specific context
  - Cannot be called again unless they are assigned to a variable or passed as an argument


# TDD Test Driven Development

* ## Modules
  - Node's way of organizing code into individual files
  - Allows you to resuse functionality accoss different parts of project
  - Dont need to copy paste code
    - Define code once in a module then import whenever needed
    - Reduces redundancy, makes codebase easier to maintain, and minimizes risks of error
  - every js file in node is implicitly a module
  - module.exports tells node what to export from a file. Defaults to {}
  - can use ```require``` with relative paths (doesn't need js extension)
  - ```const sayHelloTo = require('./myModule');```
* Node.js
  - Package manager: npm
    - Packages are self contained code libraries we can install and use in projects

* Unit Testing
  - Tells us if code is working
  - It's just: ```npm test```
  - Writing code that tests other code

```js
// Example of a simple function
function largestNumber(array) {
  return array.reduce((previousValue, currentValue) => {  
    return Math.max(previousValue, currentValue);
  });
}

```
```js
// Example of a test for that function
const array = [1,2,3,4,5];
const largest = largestNumber(array);
assert.equal(largest, 5);

```
-  ### Mocha and Chai 
    - Packages to write automated tests
    - To install ```npm install mocha chai --save-dev``` saves as dev dependecies
    - replace ```test``` with 'mocha' in JSON
    - to run ```npm run test```

-  Mocha
    - Testing framework. Looks in ```test``` folder for files to run
    - ```module.exports``` and ```require```
    - Use ```.gitignore``` to ignore sensitive files
    - In JS file add
    - In test file use require
```js      
      const assert = require('chai').assert;
      const app = require('../app');
```
    
  - describe/it statement in test file
      describe('App', function() {
        it('app should return hello', function () {
          assert.equal(app(), 'hello');
        });
      });
    

  - Chai
    - Assertion library
    - describe desired output of code
    - ```should``` ```it``` and ```assert```
    - 



  - BDD: Behavior Driven Development 
    - Write test to check behaviour of code
   - Mocha Instructions
      - Initialize a project as a num package
      - ```npm init -y``` 
      - not in test folder
       - Add test framework eg. 'mocha' to scripts
       - update scripts
       


* # Asynchronus Control Flow
  - ## Callbacks
    - Functions passed as arguments to be executed once an operation completes
    - Code modularity
```js
const forEach = (array, action) => {
  for (const element of array) {
    action(element)
  }
}

const logThatElement = (element) => console.log(element);

const logThatElementButFancy = (element) => console.log("🔥🔥" + element)

const someArray = [1, 2, 3, 4, 5]

forEach(someArray, logThatElement)

```


```js    
function fetchData(callback) {
    setTimeout(() => {
        callback("Data received");
    }, 1000);
}

fetchData((data) => {
    console.log(data);
});

```



- # Promises
A promise represents the eventual result of an asynchronous operation. The primary way of interaction with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.

A promise is an object
Promises do not rely on anything other than basic JavaScript
As of ES6, JavaScript has promises supported natively in its code. In other words, they are built into the language (via Promise)

There's more to promises than just avoiding nested callbacks, such as:

Error handling becomes much simpler with promises
Promises make asynchronous code easier to unit test
Promise.all (introduced by MPJ's video) can be used to run multiple async operations in parallel and have a single callback to see all the results together

- There are four stages in creating Promises:

  - Wrapping (syntax, or the Promise structure)

  - Thening (when it works)

  - Catching (recovery, when there's an error)

  - Chaining (where you create long sequences of asynchronous work)

- Four states of a Promise:

  1. Fulfilled (it worked!)

  2.  Rejected (failed)

  3.  Pending (still waiting...)

  4.  Settled (something happened)

##

- Objects that represent the eventual completion (or failure) of an asynchronus operation
- Handles Asynchronus operations
- Common use is when we want to run network requests to fetch data from APIs
- Three states:
  - Pending: initial state
  - Fulfilled: operation completed successfully, promise has a resulting value
  - Rejected: operation failed. Promise has reason for failure (error)
- Promise needs two callback functions, one for success (resolve) and one for failure (reject).
```js
let myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  let success = true; // Example condition

  if (success) {
    resolve("Operation was successful!");
  } else {
    reject("Operation failed.");
  }
});
```
  
- Handle result of promise using ```.then()``` and ```.catch()```
```js
myPromise
  .then(result => {
    console.log(result); // "Operation was successful!"
  })
  .catch(error => {
    console.log(error); // "Operation failed."
  });
```
- Chaining Promises
```js
myPromise
  .then(result => {
    console.log(result);
    return new Promise((resolve) => resolve("Next step!"));
  })
  .then(nextResult => {
    console.log(nextResult); // "Next step!"
  })
  .catch(error => {
    console.log(error);
  });
```
- Promise.all: multiple promises in parallel

```js
Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log(results); // Array of results
  })
  .catch(error => {
    console.log(error); // If any promise is rejected
  });

```
- ```Promise.finally```: execute block of code after a promise has settled, regardless of whether it was fulfilled or rejected. The code inside ```.finally()``` will run no matter what

```js
let myPromise = new Promise((resolve, reject) => {
  let success = true; // Change this to false to test rejection

  if (success) {
    resolve("Operation was successful!");
  } else {
    reject("Operation failed.");
  }
});

myPromise
  .then(result => {
    console.log(result); // This runs if the promise is fulfilled
  })
  .catch(error => {
    console.log(error); // This runs if the promise is rejected
  })
  .finally(() => {
    console.log("Cleanup actions or final steps."); // This always runs
  });

```
- ```Promise.all```: takes an array of promises and returns single promise that resolves when all of the promises in the array have resolved or array is empty
  - if any promises reject, ```promise.all``` immediately rejects with the reason of the first promise is rejected

```js
let promise1 = Promise.resolve(3);
let promise2 = 42; // Non-promise values are treated as resolved promises
let promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3])
  .then(values => {
    console.log(values); // [3, 42, 'foo']
  })
  .catch(error => {
    console.error(error);
  });

```

- ```Promise.any```: method that takes an iterable of Promise objects and returns single promise that resolves as soon as any of the other promises fulfills
  - if not promises fulfill, returned promise is rejected with ```AggregateError``` (built in error type)

```js
let promise1 = Promise.reject('Error in promise1');
let promise2 = Promise.reject('Error in promise2');
let promise3 = new Promise((resolve) => {
  setTimeout(resolve, 100, 'Success from promise3');
});

Promise.any([promise1, promise2, promise3])
  .then(value => {
    console.log(value); // "Success from promise3"
  })
  .catch(error => {
    console.error(error);
  });
```


- Use ```.then .catch .finally```
- Explain .all .any .allsettled .race


```js
const boilWater = () => {
  return new Promise((resolve, reject) => {
    if (Math.random() > 0.5) {
      return resolve();
    }
    return reject("Oven Broke");
  });
};

// boilWater()
//   .then(() => console.log("water is boiling!"))
//   .catch(() => console.log("The oven broke"));

const putThePastaInWater = () => {
  return new Promise ((resolve, reject) => {
    if (Math.random() > 0.5) {
      return resolve();
    }
    return reject("Pasta fell on floor");
  });
};

boilWater()
  .then(() => putThePastaInWater())
  .then(() => console.log("Pasta boiling was success"))
  .catch((error) => console.log(error));
```


```js
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve("Data received");
        }, 1000);
    });
};

fetchData().then((data) => {
    console.log(data);
});
```
  - Async/ Await
    - Syntax that allows you to write asynchronus code that looks synchronus, easier to read and maintain
```js
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve("Data received");
        }, 1000);
    });
};

const getData = async () => {
    const data = await fetchData();
    console.log(data);
};

getData();
```
  - ## Error Handling
   -  handling errors in asynchronus code done with ```.catch()``` for promises or try/catch blocks with async/await
```js
const fetchData = () => {
    return new Promise((_, reject) => {
        setTimeout(() => {
            reject("Error fetching data");
        }, 1000);
    });
};

const getData = async () => {
    try {
        const data = await fetchData();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
};

getData()
```


## Async control flow libraries
- Libraries like ```async.js``` can provide additional control flow patterns like series, parallel, and waterfall for managing complex asynchronus workflows

## Transposition:
  - Rearrange arrays
  - Eg: transform rows into columns in a matrix
  - 2D array (matrix) transposition would be converting rows to columns
    - Rows become columns. Columns become rows
  - Example: Transpose 2D matrix
    - Initalize empty array
    - Loop over each column
    - Loop over each row
    - Transpose: 
      - Initalize empty array for each column in original matrix
      - Fill array with elements from original matrix 

## Networking and TCP
- Two or more computers communicate with each other
- Transmission Control Protocol
- MAC address: name
  - 48 bits, 6 bytes long
- IP address: telephone number

## HTTP
- URL: Uniform Resource Locator
  - URL has: 
  - Protocol
  - Domain (or Host)
  - Port
  - Resource Path
  - Query Parameters
  - Anchor
- 9 HTTP request methods, but we only need to consider 4
  - ```get```: used to get data from the server
  - ```post```: used to create new data
  - ```put```: used for editing existing data on the server
  - ```delete```: used to delete existing data
- Status Codes:
  - 200: Everything went great
  - 201: Request succeeded and new resource has been created as result
  - 404: Resource not found
  - 500: The server had an error
  - 451: Resource not available due to legal reasons
- HTTP is request-response protocol where client makes requests and server sends responses
- HTTP is a text based protocol
- HTTP requests must contain verb/method(```get```) and the Path ```/about```
- HTTP requests arent always to recieve data but sometimes to save data, done via a ```post``` instead of a ```get```
- requests and responses both contrain key-value based headers
- URL: Server uses path to determine which resource to access. Parameters add additional information about what the client is interested in
- UDP: User Datagram Protocol
  - Smaller header size (8 bytes) which results in smaller packet sizes
  - Connectionless ie. there is no need to establish or maintain a connection
  - No error recovery (any corrupted packets are discarded)
  - Packets can arrive in any order
  - Useful for streaming/low latency applications
  - Example: Twitch
- TCP: Transmission Control Protocol
  - Larger header size (20 bytes)
  - Requires a connection (3-way handshake)
  - Corrupted packets are reported to the server and are re-sent
  - Packets arrive in order
  - Useful when guaranteed communication is needed
  - reliable, safe. will resend if packages are missing
- HTTP:
- Needle:
- JSON: a subset of JavaScript that allows string-representation of objects 
  - A way to convert objects into text
  - requires quotes around keys
  - Built on two structures
  - a collection of name/value pairs
  - an ordered list of values
  - Serialization: converts objects (or data structures) into a format that can be transmitted between computers (Object --> string)
    - The opposite (string --> Object) is called deserialization
  - ```JSON.parse()``` parse a string as JSON and return value
    - optionally transform the produced value and its properties
  - ```JSON.stringify()``` return JSON string of the value
  - JSON is language independent
- CRUD
  - Create: ```post```
  - Read: ```get```
  - Update: ```put```
  - Delete: ```delete```
  - when we send a safe request to read some information (safe as in a request that should have no side effects on the server), we should use the ```GET``` method. When we send a request to create a resource we should use POST. When we update a resource in an idempotent way we should use ```PUT```, otherwise when updating in a non-idempotent way we should use ```POST```. If we are requesting to delete a resource, we should use ```DELETE```.
  - Instead of PUT and DELETE, we will use POST.
  - app.listen to start

  - using nodemon, ejs and express for projects
  - separate html
  - ejs (views folder) - .ejs file (html templating) -- render the template res.render
  - body parser middlewear
  - morgan middlewear
  - view engine .set (ejs)
  - middlewear .use (morgan body parser)

## APIs Application Programming Interface
  - Allows systems to work together
  - Sets of requirements that govern how one applicatoin can talk to another
  - lets apps 'piggyback' on their offerings
  - REST API: Representational State Transfer
    - call from client to server and you get data back
  
## HTML
  - <link> used to attach a stylesheet
  - <div> generic division element container for flow content
  - <ol> for ordered list
  - <font> not valid in HTML5 - use CSS

## CSS Cascading Style Sheets
  ```html- Inline <p style=""> 
  - internal (within head) <style></style> 
  - external - new file (style.css)
    - <link rel="stylesheet" href="style.css">
    - add id and class to <p>
```

## Webservers
  - create server
 - Express: routing and middlewear framework for building web servers. put express documentation link
 - request response
 - .get (order matters) .send
 - res.send
 - params: allows us to interchange information inside of URL. (req.params)
  - no limiti to how many params we have 
 - handle dynamic paths by setting up an object
  - reference object to retrieve information
  - dynamic routing
- EJS javascript into html
  - set view engine
  - app.set("view engine", 'ejs')
  - make new folder called 'views'
  - extension: .ejs
  - res.render
- middlewear: most helpful is MORGAN(put in dev mode) - good for debugging 
-Post data params req .params.id
qwury string params

## Security and HTTP
  - Encryption vs Hashing:
    - 
  - dont store passwords as plain text - hash
  - cookies - use key and encrypt
  - dont use http use https so there is no man in the middle

  - bcrypt.js to hash passwords (npm i bcrypt) (npm i bcyptjs)
  - import bcrypt at top
  - function to save plain text password to database
   - before you save password to database: hash the password before save
    - const hashedPassword = 
    - use a salt to pass
    - salt: value provided to hashing function that will ensure different hash every time

benefit of hashing: one way process. cant get it back vs encrptying password
hashSync then compareSync
compareSync test string against hash

cookie parser saves cookies as plain text files - not good
protect login and logout routes with cookies 
encrypt cookies with 3rd party library (npm i cookie-session)

dont need cookie parser in project (tinyapp) should take it out says sandeep

to start using cookie session: app.use (middlewear) call cookie session
import cookie session object
use it
give it name
and keys
to set: req.session.email 
clear cookie: set to null
grab from req.session object
clear encrypted cookie

bcrypt - require it from bcrryptjs

to make sure targets are always encrypted tarket route: / register req should be hashed
when you save password: you should hash it
method to hash: hashsync ------bcrypt.hashsync(password, salt)
generate salt in global scope
create variable salt const salt = genSaltSync()
use hashedPassword instead of real password
before saving passwords we are hashing them
problem: old passwords still saved as plain text

compareSync - compare plainstring password to hashed value

### REST API (Restful API conventions)
  - representational state transfer
  - set of conventions, to ensure conventions are same between projects and developers
  - use http verbs to express what the request wants to accomplish
  - advantages: be able to explain this
  representation: represent information as JSON, XML, HTML
  cookie to keep track of which user
  server doesnt keep track
  stateless architecture
  transfer: transfer of information

  what happens if you dont follow REST conventions:
  
  7 http verbs
  - set of conventions that deals with accessing and manipulating resources over HTTP
  - GitHub API is RESTful, can be used to manage resources which can be accessed using an API endpoint (URL)
  - BREAD: Browse, Read, Edit, Add, Delete
  - A resource in REST is an abstraction for a document or image, or temporal service

## Stack
  - Collection of technologies used in a given system
  - Project we work on has stack
    - Web server: Node.js
    - Middleware: Express
    - Template Engine EJS
    - Database: none, just an in memory object
    - could also include: Hoisting/Infrastructure: Railway.app
  - Full stack: back end and front end
    - back end: server side technologies like web servers (Node.js), databases
    - front end: what a user sees and interacts with such as html/css/javascript and everything on client side (in the browser)

## CSS Cascading Style Sheet
  - specifies a pages appearance
  - Made of static rules: each rule takes selectors and gives specific values to a number of visual properties
    - properties applied to page elements indicated by SELECTOR
  - Precedence or Cascade
    - rules with more specific selector take precedence over a less specific one
    - a rule occurring later in the stylesheet overwrites a previous one
    - Precedence is for each property, not the entire block
  - Precedence Rules:
    - E Highest
    - F inline style
    - A: 3 specifiers: name of the element (p), its class (class1), and attribute (attr='value')
    - C: same specificity as B but appears after
    - B
    - D
    - ID has highest priority
    - inline style overwrites any styles in external stylesheets
    - !important overrides other declarations and is bad practice
    - Hex code colors: example: #FF0000 is red
    - ```ID``` used to identify unique elements on page
    - ```class```es are used to identify elements of the same type
    - element can only have 1 id but many classes
    - Classes imply stylistic or behavioural properties about an element
    - classes should be used more than ID
    - ID used when you have a unique element that behaves differently
      - also used when you need to reference them from the URL
      - IDs can work faster when targeting elements by ID
      - ID is unique identifier only used once on page
    - Use neither classes nor ID unless necessary
    - class identifier of element and can be used multiple times per day
  - FlexBox: layout module to adapt to different screen sizes and displays
    - ```diplay: flex``` add to parent property
      - also referred to as container element
      - flex direction defines direction
      - Child properties:
```js
  Given the CSS selectors below, which one would have the highest specificity and why?

p {
  color: green;
}

.text-primary {
  color: blue;
}

#header p {
  color: red;
}
```
  Specificity Calculation:
  Selector: p

  It targets all ```<p>``` elements.
  Specificity: (0, 0, 1, 0)
  0 ID selectors
  0 class selectors
  1 type (element) selector (p)
  0 inline styles

  Selector: ```.text-primary```:
    - It targets any element with the class text-primary.
    Specificity: (0, 1, 0, 0)
    0 ID selectors
    1 class selector (.text-primary)
    0 type (element) selectors
    0 inline styles

  Selector: ```#header p```:
  It targets all ```<p>``` elements inside an element with the ID header.
  Specificity: (1, 0, 1, 0)
  1 ID selector (#header)
  0 class selectors
  1 type (element) selector (p)
  0 inline styles
  Highest Specificity:
  #header p has a specificity score of (1, 0, 1, 0), which is the highest among the three selectors.
  The reasoning behind this is that it contains an ID selector (#header), which has the highest weight in specificity. It also has one type (element) selector (p).

  - Box Model:
    - How elements are displayed and sized on a webpage
    - Content:
    - Padding:
    - Border:
    - Margin:
    - Order surrounding HTML: padding, border, margin

## Semantic HTML
  - helpful structured HTML
  - non semantic not helpful structure
  - ```<article>``` splits page up into different sections
  - ```<section>```

## Normalize.css
  - Can use necolas in midterm project. renders page across different browsers
  - normalize.css
  - 

# DOM - Document Object Model
  - DOM Events occur on a web page as a user moves their mouse, clicks, double-clicks, scrolls, presses a key, releases a key, etc
  - Event driven architecture
    - when x happens do y
    - x is event. y is event handler
    - x is click of button. handler y turns on lightbulb
    - server running node.js: incoming request event. callback function handles the event(and could give response)
  - DevTools
  - Javascript manipulates the DOM


  - BOM: window screen document
  - DOM organized in a tree (DOM elements nested within other elements)
    - client side
    - events like onClick, onFocus, onLoad
    - Events that affect child element bubble up through its parents
      - event propogation
      - stop event propogation with stopPropogation()
    - BUBBLING
      - most events bubble (focus does not)
      - to stop mutliple alerts while maintaining button functionality by using event.stopPropogation() method

```js
button.onclick = function(event) {
  event.stopPropogation();
};
```
  - ensures that after the button's specific actions are executed, the event does not travel up the DOM tree and trigger any parent handlers. This effectively prevents multiple alerts due to event bubbling
  - when an element is clicked CAPTURING happens first then BUBBLING
  - When you set event it is handled during bubbling phase
  - event.stopPropogation() stops an event from triggering subsequent handleres

  - DOM traversal if you have parent grab the child
    
  - DOM event Object:
    - contains properties that provide detials about the event
    - basic, mouse, keyboard, focus, touch, event, event handling,
    -  isTrusted, altKey, bubbles, button, buttons, cancelBubble, cancelable, clientX, clientY, composed, ctrlKey, currentTarget, defaultPrevented, detail, eventPhase, fromElement, layerX, layerY, metaKey, movementX, movementY, offsetX, offsetY, pageX, pageY, relatedTarget, returnValue, screenX, screenY, shiftKey, sourceCapabilities, srcElement, target, timeStamp, toElement, type, view, which, x, y.
  - ```keypress``` event triggered only for characters
    - event is fired when a key that produces a printable character is pressed down
  - ```keydown``` shift is example. not a character producing key
    - event is fired when ANY/ALL key is pressed. event is fired before the character is actually inserted
  - Example: capitol leter 'A' (hold down shift then press a)
    - keydown: first shift triggers keydown and then will trigger its own keydown event
    - keypress: after a is pressed, the keypress event will first because a is character producing
    - keyup: finally when keys are released keyup event triggered in the reverse order
  - Webform action: specifies endpoint where the form makes a submission request
  - login form is typically post
  - search form submission typically use get
  - cancel button to go back: use ```<a>``` element
  - URL encoded is the default content type for web form submissions

## JQUERY 
  - library to demonstrate client side events
  - helps with dom manipulation
  - concise - cleaner API
    - wraps native functions with cleaner API
  - animations
  - cross browser support - fixes browser compatibility issues
    - $(window).width()
  - EVENTS in JQUERY
    - listen for events
  - JQUERY helper function is simplified and easier to use
    - $(window).width() abstracts the differences in how browsers implement features
    - consistent and reliable way to get information like the viewport width across all browsers

## AJAX 
  - Asynchronous JavaScript and XML
  - passed to a JavaScript function
  - JavaScript will modify the DOM to reflect the response from the server
  - use a JavaScript function to make an HTTP request to the server for the latest weather data. This function could be triggered to run every minute using setInterval(). Once the data is received, another JavaScript function would update the DOM with the new weather data, thus refreshing the displayed information without needing to reload the entire page.
  - improving user experience by keeping the page responsive, increasing efficiency by only requesting and updating necessary data, and reducing server load since the entire page isn't being reloaded.

- AJAX LECTURE
  - Server side rendering: EJS (tinyApp)
    - data, fetches all done via server
  - Client side rendering: Tweeter
    - client being the users device (smartphone, computer)
  - server side rendering - another computer 
  - old reddit vs new reddit example (uses ajax call)
    - allows for async calls for information
    - content on page doesnt change
  - downsides to csr/ajax: all relies on users machine
  - ssr everyone has same experience
  - fetch uses ajax (ISS project)
  - vanilla version: XMLHTTPRequest -> XHR
    - now we are using fetch to make async calls
  - use fetch to get info from API (takes 1 argument)
    - its a promise so you can use .then()
    - parse JSON
  - API usually replies in JSON
  - document.querySelector
  - addEventListener
  - document.addEventListener('DOM content loaded')
  - $(document).ready (AJAX) is the same thing nad less to type
    - write functions inside
  - can disable button after fetch has been made
    - searchButton.disabled = true
    - talked about nodes and parents ```<h2>``` if you put text in middle it is considered child and h2 will be parent. created a node 
    - can redo everything with JQUERY
    - import CDN
      - JQUERY second one on cdn not min (it doesnt have ajax)
      - class '.'
      - id '#'\
  - create element in list ```$(`<li>`)```
  - fetch(vanilla) api vs ajax call(JQUERY)
    - get and post
    - only key that is needed for ajax request is URL
      - dont have to parse with JQUERY
    - other 2 keys are success and error (dont need .then()) - error is like .catch()
      - incorporate everything into success key
    - JQUERY.ajax (also axios that i can learn later on)
    - shorthand AJAX
      - ```$.get(URL)``` or .post
        - takes .then() because it is a promise
    - by default forms refresh page - use preventDefualt ( at the begining of form)

    - ajax post
    - form request to server different than ajax form
    - CORS cross scripting policy
      - servers have this by default
      - enable CORS - require cors
        - so you can take requests
        - cors is only private serer

    - for tweeter get request at top of document.ready
    - 2 get requests in Bryans to do example one at top one later on
    - to delete something use app.post (lighthouse labs)
    - axios has delete


## Javscript in HTML
  - if at the end of the body will load the rest of the page first
  - if you put it at the top it will block rest of the page 
  - link to script in head ```<script src="></script>```
  - HTML that you write is parsed by the browser and turned into the DOM
- To do list 
    - 

    how do you ensure javascript is running after you load page - put it at the end of the body interview question
    DOM traversal interview question

    $(document).ready(function() {}) - run jquery code inside of this*** very important
    - create jquery element 

## Responsive Design
  - how webpages look across different devices
  - overflow pattern: keep links on one line but truncate the list at edge of screen. swipe horizontally to reveal hidden links, but they arent immidiately visible
    - scales to any device but users might miss links that arent visible
  - progressive disclosure: navigation hidden by default and provide toggle mechanism for users to show and hide content.
    - make sure button is labeled
  - Carousels: common method of hiding away content
    - better at solving organizational problems
    - prevents a page from getting too long and cluttered
    - hybrid approach: show content in carousel for small screens. display some content in a grid for larger screens.
    - for narrow screens display items in a row using flexbox
      - the row of items extends beyond the edge of the screen
        - use ```overflow-x: auto``` to allow horizontal swiping
    - ```scroll-snap``` feature ensures items swipe feels smooth
    - ```scroll-snap-type: inline mandatory``` snaps items into place
    - when the screen is large enough (wider than 50em) switch to grid and display items in rows and columns without hiding anything
  - Disable Viewport: should be on every webpage in the ```<head>``` area
```<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0' />```
  - easier to expand content then cut
  - viewport is area of browser
  - percentages are relative to parent
  - SASS extension (superset) - make css easier
  - superset is typescript in javascript
  - can create variable names in SASS file

# Algorithms
  - set of instructions for accomplishing a specific task
  - steps you take to accomplish something is an algorithm
  - measure speed of algorithm by counting the number of ELEMENTARY OPERATIONS
    - ex: let number = 0; number += 2; console.log(number)
    - if an algorithm performs n operators we say the running time is n
  - Elementary operations: operation that takes fixed amount of time to perform
  - most are 1 or n
  - i < array.length; // n + 1 

```js
let result = 0; // 1

for (
  let i = 0; // 1
  i < array.length; // n + 1
  i++ // n
) {
  let number = array[i]; // n
  result += number; // n
}

console.log(result); // 1

```
  -  running time of the entire algorithm 3 + (n * 3) + n + 1 which can be simplified to 4 + (n * 4). A more conventional way to write this math expression is 4n + 4.
  - Time complexity is often referred to as running time
  - Algorithms that don't deal with dynamic data, like loops, usually take constant time (no n involved)
  - Algorithms that iterate over data, involve using n based on the size of the data
  - time complexity is linear, or O(n).
- Examples:
  - constant time complexity parts are:
    - let total = 0; This is an elementary operation and takes a fixed amount of time.
    - console.log(total); This is also an elementary operation and takes a fixed amount of time.
  - linear time complexity part:
    - for (let i = 0; i < array.length; i++) { total += array[i]; } This part of the code iterates over the array, and the number of iterations depends on the size of the array (n). Each iteration involves an elementary operation (total += array[i];), making this part of the code linear in time complexity.
  - linear loop depends on n. constants elementary operations
  - i++ and console.log count as n
  - i < array.length is n +1
  - i = 0, counts as 1

```js
// 1. Array initialization: (1 operation)
const array = [1, 2, 3, 4, 5];  // O(1), array initialization

// 2. Variable initialization: (1 operation)
let largest = 0;  // O(1), initializing 'largest' variable

// 3. Loop setup: 
//    - Loop setup and first condition check take 1 operation
//    - The loop runs 'n' times, where 'n' is array.length, and each iteration involves:
for (let i = 0; i < array.length; i++) {  // O(n) - Loop runs n times
  // 4. Inside the loop body (each iteration of the loop):
  
  // 4.1 Array access: (1 operation per iteration)
  const element = array[i];  // O(1), accessing the element at index i
  
  // 4.2 Comparison: (1 operation per iteration)
  if (element > largest) {  // O(1), comparing element with 'largest'
  
    // 4.3 Assignment: (1 operation per iteration, happens only if condition is true)
    largest = element;  // O(1), updating 'largest' value if condition is true
  }
}
// End of loop. 5n + 4 is the answer
```
  - Binary Search: algorithm used to search for something in a set of ordered data
    - halving approach
    - efficient for finding an item from a sorted list of items. repeatedly divides the portion in half
    - most common way: find an item in an array
    - main idea is to keep track of the current range of reasonable guesses
  - Binary search guessing game (english):
    - step-by-step description of using binary search to play the guessing game:
    - Let min = 1  and max = n.
    - Guess the average of max and min, rounded down so that it is an integer.
    - If you guessed the number, stop. You found it!
    - If the guess was too low, set min to be one larger than the guess.
    - If the guess was too high, set max to be one smaller than the guess.
    - Go back to step two.
  - Prime search game Binary search
    - Let min = 0 and max = n-1.
    - Compute guess as the average of max and min, rounded down (so that it is an integer).
    - If array[guess] equals target, then stop. You found it! Return guess.
    - If the guess was too low, that is, array[guess] < target, then set min = guess + 1.
    - Otherwise, the guess was too high. Set max = guess - 1.
    - Go back to step 2.
  - Binary search: in an array of a million would require only about 20 comparisons. linear up to 1 million
  - algorithm input size doubles: time complexity O(log n)

  - Difference between linear and quadratic time

  ```js
  function arrayContainsSum(array, sum) {

  for (
    let i = 0; // 1
    i < array.length; // n + 1
    i++ // n
    ) {
    const element1 = array[i]; // n

    for (
      let ii = 0; // n
      ii < array.length; //n + n^2
      ii++ // n^2
      ) {

      const element2 = array[ii]; // n^2

      if (element1 + element2 === sum) { // n^2
        return true;
      }
    }
  }
  return false; // 1
  }
  // Add all the operations together to get a running time of 3 + 5n + 4n^2
  ```
  - n^2 causes high growth curve. avoid with nested for loops
  ```js
  for (let i = 0; i < array.length; i++) {
    console.log(array[i]); // n
  }
  ```
  - nesting of loops adds many extra operations to an algorithm 
  - linear faster than quadratic

  - Quadratic algorithms have a much slower running time than linear algorithms
    - can be created by nesting loops. common when comparing every item in an array to every other item in that array
  - Separate arrays run in a * b times

## Big O Notation
  - official way to determine efficiency of algorithms
  - written as ```o()``` 
    - describes how the number of steps in algo scales relative to its input
    - does the algo grow linearly, exponentially, or logarithmically?

  - 3 main criteria:
    - only care about arbitrarily large input
      - Big O notation focuses on how an algorithm performs when it's given arbitrarily large input.
    - drop the non dominant terms
      - only care about mentioning the highest order term ```O(n^4)```
    - drop constant terms
      - Big O notation is used to describe how an algorithm's complexity grows relative to its input. It is not used to describe the exact running time of an algorithm.
      - when an algorithm grows lineraly it is said to have O(n) complexity
  - Examples:
    - 2n + 3 will grow linearly, O(n)
    - 100n^2 will grow exponentially, O(n^2)
    - log n + 1000000000 will grow logarithmically, O(log n)

  - More examples:
    - Constant O(1) - always takes the same amount of time ```array[2];``` no matter how big array is ```array[2] + array[3] + array[4];```
    - Linear O(n) - operations grow lineraly relative to its input
      - summing every number in an array is an example
    - Quadratic O(n^2) - operations directly proportional to the square of the size of the input
      - find all duplicates in array, first unique number in array
    - Logarithmic O(log n) - operations directly proportional to the logarithm of the size of the input

  - as the input size n grows larger, constants and non-dominant terms become insignificant. In the expression 1000n + n^2, for instance, the 1000n term becomes negligible compared to n^2 as n increases, so we simplify the complexity to O(n^2). This simplification makes it easier to compare the efficiencies of different algorithms.


## SQL - Structured Query Language
- Relational Database Management Systems (RDBMS)
  - type of management systems (eg PostgreSQL, SQL, Oracle)
  - one database per application
    - one database has many tables
  - PK: primary key: first most important key for any row of a table
  - FK: Foreign Key: values we use to trace our routes between tables
- ERD entity relationship diagram - how tables are connected
  - Entity
  - Attribute
  - Primary Key
  - Relationship
  - Cardinality -crows foot
- Bridge table for ERD
- DDL - data definition language
  - how we create our database
- DML -data manipulation language
- schema: blueprint of what table will look like
- INTEGER
- TEXT/VARCHAR limit is 255
- Serial primary key
- ORDER BY clauses come after WHERE
- The LIMIT clause should be at the end
- SELECT queries start with the SELECT clause
- PostgreSQL: might need to restart everytime computer restarts
  - default PostgreSQL user will be labber with labber as the password
- To start PSQL
  - ```sudo service postgresql start``` peter heyboer lighthouse every time
  - ```psql``` 
  - ```sudo -i -u postgres``` *** this works to login to postresql as super user
  - then run ```psql```
  - switch to bootcampx database ```\c bootcampx```
  - exit postgresql with ```\q```
  - connect right to database ```psql -U peterheyboer -d bootcampx```
  - connect to database as superuse ```psql -U postgres -d bootcampx```
- JOING TABLES
  - INNER JOIN - gives us rows where there is a match between 2 tables
  - OUTER JOIN - times when we do want to include datya where
    - LEFT RIGHT FULL
    - returns all results for one of the tables even when the join condition is not met
- Use SQL to query your data, not JavaScript. JS is a lot slower
  - indexed version of JS is better but still slower
- nested query - select inside of a select

- consider a scenario where you have a students table and a projects table. If you want to list all students along with their project names, including students who haven't started any projects yet, a LEFT JOIN would be appropriate. Here's how you might write the SQL query:

  - SQL notes
  - 

## Database Design 
  - state of the system - entire data delt with at the time
    - what are the different pieces of data 
- Data: information stored by a computer
- databse: easy access and manage
- user story: as a user i should be able to log in
  - there are a lot of user stories. scenarios
  - entity
- database: adapt to changing needs over time
- Normalization: normalize data by making another table DRY
- entities tables crows foot is the relationship between
- NOT NULL means there has to be some value cannot be left empty 
- Primary Key - uniquely idenifty record in your database
  - must be unique cannot be null
  - PK and FK must be same data type
- table and field names written in snake_case
- table names pluralized
- refer to PK as ID
- crows foot relationship types
  - one to one - related to one and only one example sin to person name
  - one to many - employee and position, author and books, user and posts
  - many to many - movies and actors example, students and courses
  many - many never represent it as that. break it down into one to many relationships
  - making an ERD - draw.io
  - one tomany : parent and child relationship. authors parents books are child of parent
  - earaser.io is a whiteboard to draw on 
  - cant put FK into 2 tables? - use bridge table
  - many to many use a bridge table - third table (junction/middle table) makes one-to-many relationships
- 1NF: first normal form
  - ensures data is stored in a consistent and structured way
  - in 1nf form if table has atomicity, uniqueness of rows, no repeating groups
  - put relationships in own table
- Foreign Key:
  - field in one table that refers to Primary Key in another table. This is how we model relationships
  - in one to many relationship: FORIEGN KEY IS ON THE MANY SIDE
- Many to many relationships - make into multiple one to many relationships with bridge table (join table)
- SQL commands that we use to define the database schema are Data Definition Language statements (DDL) (CREATE ALTER DROP)
- store a number in PostgreSQL, ten numeric types: SMALLINT, INTEGER, BIGINT, DECIMAL, NUMERIC, REAL, DOUBLE, SMALLSERIAL, SERIAL, BIGSERIAL.
- ```ALTER TABLE```
```
 ALTER TABLE table_name
ADD COLUMN new_column_name data_type constraint;
```

- delete table: DROP TABLE IF EXISTS users CASCADE;
- If the primary key is SERIAL, then the foreign key should be INTEGER.
- Names, emails, usernames and passwords can all be stored as VARCHAR(255). Students to cohorts would be cohort_id. The type would be INTEGER .
- Dates would use the DATE type. If we needed date and time, use TIMESTAMP.
- INSERT INTO
- Delete: DELETE FROM table_name WHERE condition;
  - always include a where clause when deleting 
- Update: UPDATE students
SET name='Callisto Caiazzo', email='ccaiazzo@gmail.com', github='callcazz'
WHERE id = 3;


## SQL to EXPRESS
  - need to know for midterm - refer to lecture
  - client makes request to server. server sends response.
  - server talks to database. database response back to client
  - adding database now. database sends back response via JSON
  - server sends back to client to be displayed in browser
  - request from client to database is possible*
  - steps: login to psql (psql -U development)
  - to add the file use \i
  - PostgreSQL
  - BREAD - browse, read, edit, add, delete
  - npm init -y
  - create new config file
  - default port for postgresql is 5432
  - make query after connection is made
  - console.table to see it in a table 
  - fetchAll vs query
  - fetchAll remove callback
    - can make it so it only returns results. catch errors with .catch
    - fetchAll can export function
  - sanitize querys - parameterized queries (array of values)
  - pool and client connect to database
    - client is a one way connect
    - in the event of many users coming to website and inserting info: use pool
    - more than one connection at a time: use pool
    - const {pool} = pg;
    - client and pool are the exact same
  - 1 file for each table in queries
  - pool and config and pg require in different file (connection.js)
  - .env (add to gitignore)
    - dependency - dotenv
    - hide information so it doesnt get pushed to github
    - process.env. (placeholdesr in connection file for config)


## Team git workflow (breakout session) - for Midterm
  - Midterm work in teams. Chose project together
  - git vs github
  - git:
    - make sure you know how to see branches
    - git is common line application (version control software)
    - git allows for incremental changes of code (snapshots of code over time - commits)
    - changes stored locally in '.git'
    - git init
  - Github - not local. in the cloud, remote from computer
    - application that runs on the web. It is where we can push code to to collaborate
  - Cloning: copy of a repo from github to local machine
  - Forking: creates a copy of the repo on Github
    - takes repo (with commit history) to your github
    - does not update local machine
    - all happens on github
    - if you want on your device, you fork and then clone
    - Use this template button is an example - but does not contain commit history
  - Merge Conflicts: two or more devs changing the same code in the same file
    - git log: shows the log
    - highlights the line and gives 3 options with how to deal with it
      - 1: accept the current changes - keep code
      - 2: accept incoming changes - keep the code im pulling down 
      - 3: accept both
      - talk to the other devs about the conflict
      - we will see intentional merge conflict in project
  - Team Git Workflow: 
    - final project repo from scratch
    - midterm will Use this template
      - one person on team will be owner of repo that we will create
      - add teammates as collaborators
        - go into settings and manually add them in
        - only owner can add collaborators
        - git add remote origin
        - as professional developer never work on master or main branch
        - create new branch: git checkout -b 'namebranch' (create and move to branch)
        - make sure branch is compatible with main branch
        - git pull origin main
        - git checkout to change branch 
        - git merge main
        - vscode shows on bottom left which branch you are on
        - make sure you are working on your branch
        - git status to check modifications
        - pull request: merge my branch into main
      - decide if you want pull requests or to push locally
      - pull request is industry standard
  - other peoples branches: 
    - keep your branch up to date
    - branch off of someone elses branch ( git checkout -b) - main is fine 


## Data Structures - Trees
  - Each circle in the tree represents a Node
  - A node represents a key entity and contains data about that entity
    - All connections between notes are edges
  - Node at the very top of the tree is called Root Node
    - Nodes on the very bottom are Leaf Nodes
    - Every node except for Root has a single parent node
    - every node that is not a leaf node has one or more children nodes
  - All children with the same parent are siblings
  - Use a method to link the nodes
    ```js  
    addSubordinate(subordinate) {
      this.subordinates.push(subordinate);
      subordinate.boss = this;
    }
    ```
  - link nodes ```ada.addSubordinate(craig);```
  - trees are good to use when data has hierarchial relationships
  - can build a tree as long as nodes have a single parent and many children

  - tree traversal: 
    - breadth first traversal will check the nodes cloest to the root node before checking further away
      - start with root node
      - move onto the roots children
      - move onto those nodes children
    - Depth first traversal
      - visit each node on an entire path, all the way out to a leaf node before visiting nodes on the next path

  - Sub trees
    - tree is a recursive data structure
    - recursive case: if thres a subtree, traverse subtree
    - base base: if theres no subtree, do nothing
  - Depth first traversal:
    - visit root node of tree
    - get first unvisited child sub tree of current node
    - do step 1 with sub tree

    ```js
      class Node {

      constructor(data) {
        this.data = data;
        this.parent = null;
        this.children = [];
      }

      depthFirstTraversal() {

        console.log(this); // 1

        for (const childNode of this.children) {
          childNode.depthFirstTraversal(); // 2
        }
      }
    }
    ```

# Midterm
- https://web.compass.lighthouselabs.ca/p/web-flex-2/projects/midterm-proj
- https://doodle.com/en/
- node skeleton
  https://github.com/lighthouse-labs/node-skeleton

- 


# Midterm Project Notes

Option 9: Schoodle
Doodle is great for scheduling events within a group. Your job is to create a simpler, more modern version of it.

Requirements:
- visitors can create an event proposal in much the same way as Doodle, by specifying:
  - event title and description
  - their own name and email
- organizers can then send the unique URL to possible attendees via their own communication workflow (email, Slack, Messenger, etc.)
- attendees visit the unique URL and:
  - specify their name and email
  - specify their availability (yes/no only) for each possible time slot
  - view all responses including their own
  - modify their response
- the unique URL should be secret and thus not use a simple auto-incrementing integer but instead a larger ID that is harder to guess (much like how secret gists work on GitHub)
- note: this app does not follow the typical user authentication process: users don't need to register or log in and the only way to access the Schoodles is via links

 ## Simplified Requirements for Schoodle
- visitors create event by specifying event title, description, and their own email and name
- organizers send unique URL
- attendees visit URl and specify name and email. availability for each time slot. view all responses including their own. modify response.
- URL should be secret and not use auto incrementing integer 
- no login required

# REACT
- Javascript library for building user interfaces
- React has a way to manage the state in our app. Takes care of updating and rendering what we see in the browser to reflect the current state
  - encapsulated components that manage their own state then compose them to make complex UIs
  - a group of elements can be stored inside a component and a component can be called by another componenet
- Template Engine: special tag t execute code, to show dynamic content
  - JSX allows us to create HTML through the rendering process and declare what the UI should look like
  - not required to use JSX but many reasons to choose
- react requires that we start component names with capital letters
- element can be rendered into any DOM node using react-dom library
- most apps call ReactDOM.render(element, container) a single time to render the application
- jsx is similar to EJS in its useage

## JSX Rules
- 1:
  - All tags must be closed
    - 2 ways to close a tag
      - Use 2 tags
      - Use one self closing tag
- 2: 
  - child tag must close before its parent. We are creating a tree structure so the last one to open is the next one to close
- 3: 
  - All JSX expression must result in one root level element. A function can only return one value. A component is defined using a Javascript function so the same rules apply
- 4: 
  - No HTML comments
  <!--- Not allowed --->
    {/* Allowed */}
- JSX is not a template language but it shares the declarative benefits of one. 
- take any JSX expression and render it to the DOM using ReactDOM.render 

- 2 types of components in React
  - Funcational
  - Class

## React Lecture Jan 21
- React is a library
  - framework is heavier
    - database management, routing
- react is a client side rendering app
  - Backbone and jquery had limitations
    - quick DOM updates, complex, and lack of state management
    - client side rendering depends on your PC resources
    - virtual DOM solves this - virtual dom sits on top of real dom
    - client sees virtual dom
    - allows for quick renders
  - components - small bits of HTML that we can reuse through out the app
    - functions that return HTML (uses JSX) (javascript xml)
    - add javascript code before return line
- create-react (use snake case no camel case)

- babel - translate newer javascript into older for older browsers
- webpack: bundles your javascript, html, css, images all for browser
  - minimizes size of files so it can load better
  - Vite - can create react apps
    - not able to use old browsers (older than 2018)
  
- components
  - functional components can only return only element - a wrapper
  - built in argument props
  - props returns as an object
    - labelling the information that is coming into the component
    - prop names are passed directly into component 
    - wrapped in curly brackets

- single source of truth: only pass in what the component needs
- conditional rendering
- react keeps tracks of components by using keys
  - avoid using indexes for keys
  - keys need to be unique to the component
  - if there is an ID you can use that becuase it is truly unique to each list
# React Libraries
- Redux


# Front-end Framework
- understand scope of project
- understand limits of the framework for problems or adding features down the road
- Angular
  - This language is a superset of Javascript called Typescript
  - real time synchronization between the componenet and HTML
  - strict environment to better recognize errors
- Svelt
  - new. not as many libraries as others
  - fast and lightweight
  - lacks community support
- Vue.js
  - simple syntax - easier learning curve

### React notes - Data structures
- Arrays are good at storing information in order and are used to store a collection of independent items
  - use when we want to store something like a list of tasks, or a browser history
  - becomes problematic when we want to Create, Read, Modify elements that are not at the beginning or end of an array
    -  would first need to find item in the array - iterate through, retrieve index then execute modification
    - another problem is if you want to store related data (list of characteristics)(information about an animal example)
      - makes information harder to read. if it was stored in object we could have keys describing properties
- objects are good at storing related information with labels. order is not important, as long as labels attached to values
  - when order is important objects can become problematic'
  - have to create the keys yourself - extra step 
  - slower to access the values since we need to process the object first
- independent items: array
- related items: maybe object
- access specific value? maybe object
- need to remove first or last element? -array
- can change data structure 
- object.entries method returns an array of key value pairs from the object and map is then utilized to extract the values resulting in an array of objects
- object.values() works well to turn an object containing other objects into an array

- complete data structure to store the properties of one metal
```jsx
 {
    name: "1084",
    type: "Carbon Steel",
    composition:  ['iron', 'carbon', 'manganese', 'phosphorus', 'sulfur'],
    forgingTemp: { min: 900, max: 1200 }
  }
```
- Building a data structure:
  - Determine what data you need
  - Determine what operations you need to perform on the data
  - Organize the data
  - Determine if certain data is related or independent and decide what kind of substructure is needed
  - Start small, then grow your structure

- React Props
  - pass data to components as "props" short for properties
    - properties we give to a componenet
    - can be piece of data or entire function
    - JSX pass properties same way assign attributes to HTML elements
- Passing Props (2 different ways):
  - 1. list each one as key=value pair
  - 2. use spread operator to destructure an object {...{key: value}}
    - useful if you want to pass all the properties of an object as individual variables

- spread operator makes it easier to pass all the properties of an object as individual props to a component, without manually specifying each key-value pair

- Using props
  - properties passed to component are automattical stored in an object
  - object is available as a parameter in the component definition
  - its common for a prop to be an entire function definition.
    - remember not to call the function when it is being passed down (no parentheses())
    - pass only the function reference to the component

```jsx
function doStuff() {
  console.log("This is the doStuff function.");
  // do stuff
}

// CORRECT: doStuff is passed as a reference!
<Profile doStuff={doStuff} />;
```
- when you pass the function as a reference, react only invokes the function when the even occurs(button clicked). when you invoke the function directly it will execute immediately not when the event happens
- props.children
  - built in children key
  - contains anything that is inside the tags of a component
- props.children is anything that is passed to a component inside its tags
  - with any component we can access the children through props.children
  - Event handler names such as onClick, onSubmit, and onChange are only keywords in the JSX tags that resemble HTML. They are not special keywords when used as props in your own components

- Arrays in JSX
  - .map() loops through an array and modifies each element with callbacks
- mapping through elements
  - .map() method allows us to loop through an array and modify each element with a callback
    -ex. array of numbers and we want to double we can do it with .map()
  - .map() can modify each element and return a brand new array
    - can modify each elemtn and return an <li> element for each item using string literals
    - improve further by removing string literal and pass them in curly braces for React
    - React supports arrays filled with HTML elements. It will go through each one and attempt to render it in the component.
    - if we attempt to render, we get warning a key should be provided for all list items
  - dont index the element
    - we want the keys to be unique
    - always use unique key

- Props vs State
  - Props is:
      Immutable;
      Read-only; and
      Passed down from parent to child components.
  - State is:
      Immutable, but can be updated via setState;
      Read and writeable;
      Locally owned by its component; and
      Can only be passed as props.
- when to use: depends whether or not the component owns the data
  - when using state data is locally owned and updated by the component itself
  - props are read only so the data is externally owned by the parent component and passed down to the children components

- data traversal - unidirectional
  - parent can pass down to component via props
  - child cannot directly send data back up through props
    - instead an event handler is used to pass data from child to parent
  - when communicating between siblings data must first be passed to their common parent component through an event handler function. data can then be sent down to the second sibling component thropugh props by the parent

- events
  - allow information to be sent from child to parent
  - must define event handler in parent component and pass it down to the child as a prop
    - event handler defined in parent component
    - event handler function passed as prop to child
    - child calls event function with relevant data as arugments
    - the parent component handles the event and uses data
- child components cannot pass data up to its parents

- hooks
  - prior to hooks functions couldnt handle or manage states
  - stateless or "dumb components"
  - hooks utilized to invoke different features of react into functional components
  - custom hook is a function that starts with the word "use"
  - 2 most common are useState and useEffect

- useState
  - in react local variables do not persist between renders
    - if component is re rendered we lose information we were trying to capture

- Rules of hooks
  - Call hooks at the Top level 
    - call hooks at top levels before our render is called and after our function component declared
    - we call hooks at the top level because React relies on the order of hook calls to maintain the state and effects correctly.
    - if we dont follow the rule and call hooks inside loops conditions or nested functions it can lead to unpredictable behaviour and errors in app
  - Call Hooks from React function
    - not from regular javascript functions.
    - call from react function components or custom hooks


- React State
  - a state is the current status of something
  - state refers to the data that a component manages and stores
    - represents a components current state or condition such as values or properties
  - state enables reat components to respond dynamically
    - when a components state changes, react automatically re renders
  - the state in react allows us to dynamically change one or many elements at once based on one variable
  - to store state we use hooks - useState hook

- Using states in react useState
  - returns an array
  - first element is the current value for the state
  - second element is a function that can update the state and cause a render
  - array destructuring done on left side of assignment operator to create two variables from the array returned by useState

  - useState hook uses array destructuring to return 2 different values
    - one is used to get a value (getter)
    - one is used to set a value (setter)

  - to prevent function from being invoked when the page renders we need to pass any arguments to that function inside another function (wrap in outer function)
```jsx
  <Button onClick={() => setCount(count + 1)}>Increment</Button>
```


### React State lecture Jan 28
- we can use veet (veet@latest)
  - npm run dev to use
  - instead of div can return empty shell <></> instead of <div></div>

- react state
  - need a variable that persists between rerenders and something to trigger a render

  - setState is async, and we cant await it
    - takes a little bit of time, console log will show up first 
    - if we are troubleshooting states use dev tools not console log

- how does react discern the difference between components
  - react recognizes a component by its function or class declaration
  - when using component in JSX react identifies it as a component if it is Capitalized
  - if multiple components rendered in a list, react uses key attribute to differntiate

- Lifting state up
  - In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called *“lifting state up”*.

- Stale State
  - never want to modify state directly
  - use previous state
    -prev or previous
    - instead of reffering to state directly

- Updating states of components
  - when doing actions on events create a function that only needs to be referenced
```jsx
const handleClick = (event) => setState(event.target.value ? event.target.value : "");

  <button onClick={handleClick} />

  // instead of

  <button onClick={event => setState(event.target.value ? event.target.value : "")} />
```

- useReducer Hook
  - useReducer is called with two parameters, a reducer function and the initial state, which is set to 0.
```jsx
  const [sum, dispatch] = useReducer((state, action) => {
  return state + action;
  }, 0);
  ```

  - hook returns an array of 2 elements
  - dispatch is a function that achieves the same goal as setState

- useReducer can do it all, but useState is still useful for managing simple state transformations
  - more complex state logic use useReducer

- Controlled components
  - Form elements keep track of their own state
  - html has built in state management but preferable to use React

  - components that override HTML form elements to let react control their state area called controlled components

  - Pattern:
    - set a variable that is stored in state as the value attrubute on the form element
    - use onChange event that uses the setter of your state to set a new value when the input changes

    1. A user types a single character "A" into the input element.
    2. The onChange event handler is triggered.
    3. It invokes the setWord function to change the state.
    4. When the state changes, React calls the component function.
    5. The useState call returns the current value which is "A".
    6. The input element has its value set to "A".
    7. The browser displays the "Your word is: {word}." message as "Your word is: A."

- Fragments
  - React Rule: JSX expressions must have only one parent element
    - components can only return JSX with one root element
    - conditional expressions that resolve to JSX must also only have one root element
      - fixed by wrapping both elements in a <div>
        - is <div> necessary for the page?
        - extra div tags can result in bugs related to CSS
      - consider using <Fragment>
        - does not create any extra DOM nodes which can clutter HTML and cause layout problems

```jsx
        return (
          <React.Fragment>
            <h1>A heading</h1>
            <p>A paragraph</p>
          </React.Fragment>
        )
```
OR pull fragment with import statement
```jsx
import React, { Fragment } from 'react';

return (
  <Fragment>
    <h1>A heading</h1>
    <p>A paragraph</p>
  </Fragment>
)
// Shorthand
return (
  <>
    <h1>A heading</h1>
    <p>A paragraph</p>
  </>
)
```
- shorthand method does not accept attributes (props)
  - need to use <Fragment>

- Conditional Expressions that result in Multiple Elements
  - if you have 2 expressions that do not resolve to single root elements, wrap in <Fragment>


  const userLoggedIn = false;
```jsx
return (
  <Fragment>
    {userLoggedIn ? 
    <>
      <h1>Success!</h1>
      <p>You are logged in.</p>
    </>
    :
    <>
      <h1>Warning!</h1>
      <p>You are not logged in</p>
    </>
    }
  </Fragment>
)
```
## State Management Lecture Jan 30 - Immutibility
  - most bugs in apps are related to the state
  - useReducer is like redux

- look up principle Copy by Value

  - non primitive values are copy by reference
  - references object instead of copying the value

- use Vite now because create react is depcreciated


- never update your variables directly in react 
- spread operator to make copy 
- libraries to help with immutibility but know the steps involved

- useReducer

- Look up:
  - spread operator
  - object.assign
  - virtual DOM
  - how to automatically add curly brackets for object destructuring
  - dispatch - update in real time

- Tech interview 2
  - go over higher array methods

- final Project
  - can use Zutan??




# Technical Interview #2
- Topics: SQL, Algorithms, APIs, Code organization (code separation/linting), refactoring, testing, ERD, Table relationships, using objects and loops
- Review: 
  Database Design
  Visualizing Databases
  Relationships Between Tables
  JOINing Tables
  A Visual Explanation of SQL Joins
  Creating ERDs
  Objects - Iteration

## SQL and Database
- CRUD create read update delete
  - ```INSERT INTO table_name (column1, column2) VALUES (value1, value2);```
  - ```SELECT column1, column2 FROM table_name WHERE condition;```
  - ```UPDATE table_name SET column1 = value1 WHERE condition;```
  - ```DELETE FROM table_name WHERE condition;```
- Filerting and sorting
  - WHERE: SELECT * FROM employees WHERE age > 30;
  - ORDER BY: SELECT * FROM employees ORDER BY last_name ASC;
  - LIMIT/OFFSET: SELECT * FROM employees LIMIT 10 OFFSET 5;
- Primary Key (PK) - unique identifier for table records
- Foriegn Key (FK) - field in one table that links to primary key of another
- Relationships:
  - One-to-One: One record in table A relates to one record in table B.
  - One-to-Many: One record in table A relates to many records in table B.
  - Many-to-Many: Many records in table A relate to many records in table B (often implemented with a junction table).
- SQL JOIN 
  - INNER JOIN: Returns rows when there is a match in both tables.
    SELECT a.column, b.column
    FROM table_a AS a
    INNER JOIN table_b AS b ON a.common_field = b.common_field;

  - LEFT (OUTER) JOIN: Returns all rows from the left table and matched rows from the right table.
    SELECT a.column, b.column
    FROM table_a AS a
    LEFT JOIN table_b AS b ON a.common_field = b.common_field;


  - RIGHT (OUTER) JOIN: Returns all rows from the right table and matched rows from the left table.
    SELECT a.column, b.column
    FROM table_a AS a
    RIGHT JOIN table_b AS b ON a.common_field = b.common_field;


  - FULL (OUTER) JOIN: Returns rows when there is a match in one of the tables.
    SELECT a.column, b.column
    FROM table_a AS a
    FULL OUTER JOIN table_b AS b ON a.common_field = b.common_field;


- Venn diagram explanation:
  - INNER JOIN is the intersection.
  - LEFT JOIN is the whole left circle with the intersection.
  - RIGHT JOIN is the whole right circle with the intersection.
  - FULL JOIN is the union of both circles.

- Creating ERD
  - 1. List all entities
  - 2. identify PK for each entity
  - 3. define relationships between entities (FK)
  - 4. draw erd with crows foot notation for relationships

## Algorithms
- Sorting: Bubble sort, merge sort, quick sort
- Searching: linear, binary
- Big O notation: time and space complexity
- recursion: function calling itsself to solve smaller instances of a problem

- For...in Loop: iterate over object properties
- For...of loop: iterate over iterable objects (arrays)

- Array Methods:
  - .forEach() - iterates through array, does not return new array or value
    - logging, updating DOM element
  - .map() - transforms array by function - returns new array
  - .filter() - creates new array with element provided
  - .reduce() - reduce array to single value
    - reducer function on each value

- APIs
  - RESTful API principles
    - stateless use of HTTP methods (GET POST PUT DELETE)
  - API request using fetch
```js  
    fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));
```

- API testing: Postman (send requests and inspect response)

## Code organization
- break code into reusable modules or files
- keep concerns separated (logic vs UI)

## Refactoring
```js
// Before refactoring:
function processData(data) {
  // process first part
  for (let i = 0; i < data.length; i++) {
    // process data[i]
  }
  // process second part (duplicate logic)
  for (let i = 0; i < data.length; i++) {
    // another operation on data[i]
  }
}

// After refactoring (Extract Function):
function processItem(item) {
  // common processing logic
}

function processData(data) {
  data.forEach(processItem);
  // call processItem again if needed in a different context
}
```

## Testing
- Mocha and Chai
```js
  // Using Mocha and Chai for assertion:
  const { expect } = require('chai');
  describe('Array', function() {
    it('should start empty', function() {
      const arr = [];
      expect(arr.length).to.equal(0);
    });
  });
```

## Object manipulation
- Object.keys() - returns array of objects keys
- Object.values() - returns array of objects values
- Object.entries() - returns array of objects key value pairs

## Asynchronus control flow
- managing operations without blocking main thread
- call stack and stack queue
- setTimeout setInterval

## Callbacks
- functions passed as arugments to other functions, executed once asynchronous operation completes

## Promises
- create promise
- consume promise with .then() .catch() .finally()
- chain promises for sequential asyncrhonus operations

## SQL practice

/*
Sample Dataset
Imagine we have two tables: Employees and Departments.

Employees Table
employee_id	first_name	last_name	department_id	salary	hire_date
1	Alice	Johnson	1	60000	2018-03-15
2	Bob	Smith	2	55000	2019-07-22
3	Charlie	Davis	1	70000	2017-01-10
4	Diana	Brown	3	50000	2020-11-05
5	Evan	Wilson	2	65000	2016-09-30
Departments Table
department_id	department_name
1	Engineering
2	Marketing
3	Sales

*/
//Write a query to select the first name, last name, and salary of employees who earn more than 60000.
```
SELECT first_name, last_name, salary 
FROM Employees
WHERE salary > 60000;
```
//Calculate the average salary for each department.
```
SELECT department_id, AVG(salary) AS average_salary
FROM Employees
GROUP BY department_id;
```
//List each employee’s full name along with their department name.
```
SELECT CONCAT(first_name, ' ', last_name) AS full_name, department_name
FROM Employees
JOIN Departments ON Employees.department_id = Departments.department_id;
```
// Find the employees who earn more than the average salary of their department.
```
SELECT first_name, last_name, salary, department_id
FROM Employees
WHERE salary > (
  SELECT AVG(salary)
  FROM Employees
  WHERE department_id = Employees.department_id
);
```
//Retrieve all employees hired after January 1, 2018, and order the results by hire date in ascending order.
```
SELECT employee_id, first_name, last_name, hire_date
FROM Employees
WHERE hire_date > '2018-01-01'
ORDER BY hire_date ASC;
```
//Find the departments that have more than one employee.
```
SELECT department_id, COUNT(employee_id) AS employee_count
FROM Employees
GROUP BY department_id
HAVING COUNT(employee_id) > 1;
```
//Increase the salary of all employees in the Marketing department by 10%. Assume the department_id for Marketing is 2.
```
UPDATE Employees
SET salary = salary * 1.10
WHERE department_id = 2;
```
//Delete all employees from the Sales department. Assume the department_id for Sales is 3.
```
DELETE FROM Employees
WHERE department_id =3;
```

## Create simple RESTful API
```js
const express = require('express');
const app = express();
const PORT = 3000;

// Sample data store
let users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' }
];

app.use(express.json());

// GET /users
app.get('/users', (req, res) => {
  res.json(users);
});

// POST /users
app.post('/users', (req, res) => {
  const newUser = {
    id: users.length + 1,
    name: req.body.name
  };
  users.push(newUser);
  res.status(201).json(newUser);
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## API Calls
- using fetch
```js
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => {
    // Check if the response is OK (status in the range 200-299)
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    // Parse the JSON from the response
    return response.json();
  })
  .then(data => {
    // Log the data received from the API
    console.log('Data received:', data);
  })
  .catch(error => {
    // Handle any errors that occurred during the fetch
    console.error('There was a problem with the fetch operation:', error);
  });
```
### using async await
```js
async function fetchTodo() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    
    // Check if the response is OK (status in the range 200-299)
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    
    const data = await response.json();
    console.log('Data received:', data);
  } catch (error) {
    console.error('There was a problem with the fetch operation:', error);
  }
}

fetchTodo();
```



## ERD
Design an Entity Relationship Diagram (ERD) for a simple library system that includes the following entities:

- Books: Attributes include book_id, title, and author_id.
- Authors: Attributes include author_id, name.
- Members: Attributes include member_id, name.
- Loans: Attributes include loan_id, book_id, member_id, and loan_date.

## Summing object.values
```js
//example object
const sales = {
  apple: 10,
  banana: 20,
  orange: 15
};

function totalSales(sales) {
  const values = Object.values(sales);
  return values.reduce((total, num) => total + num, 0)
}
```

## Object.entries
```js
const user = { name: 'Alice', age: 30, city: 'New York' };

function objectToStringArray(obj) {
  return Object.entries(obj).map(([key, value]) => `${key}: ${value}`)
}
```
## TI #2
look up IIFE
now we have bundlers 

## React custom hooks lecture Feb 4
- custom hooks
  - 3 rules
    - 1. needs to be javascript function
    - 2. when we import it, it needs to be called at the top of our functional component
    - 3. needs to start with the word ```use```

  - separate into foler called hooks (javascript file- this is a strict javascipt function) (jsx file returns html or jsx)
  - import and export
  - arrays need to be imported in the same order - could create potential bugs
  - import object instead because the order will not matter
  - a hook is also an independent state
    - same hook different states
- useState
- useEffect - execute code after first render
  - only executes once (dependancy array) after initial render
  - put api fetch call in here

- can use Bryans api for movies in final project if we want

- React component
  - JS function that returns jsx

- Component Render
  - call the function

## Photolabs and React notes
- In React, it is required that each item in a list of children has a unique identifier called a key. The value must be named key and each key must be unique.

## Lecture Feb 6 - useEffect hook
- dependency array and use effect hook

- cleaning up side effects

- pure function: function that walways returns the same output for the same input and has no side effects (which is a keyword)
  - key concept of functional programming

- impure function: function that might not return the same output with the same input. and might modify an external state (side effect)

- side effect would be reaching out to external dependency
  - variable outside of function
  - making api call
  - updating dom

- pure is important : predictable behaviour
  - separation of concerns
  - reuseability
  - testability
  - performance optimization (memoization)

  - hard to test impure functions

- reacts only job is to calcuate ui 
- side effects timers or intervals 
- rendering is calculating the UI part

- useeffect hook for side effects
- useEffect: import then declare it.
  - dependency array 
  - empty dependency array: 
  - no dependency array: side effect will run everytime component is rendered
  - [] - side effect will run once when component mounts
  - [state variable] side effect will run evertime given dependency changes

  snippet to generate component**

- clean up side effects with a return statement 

- for project: fetch data to display in app

- fetch MDN docs
  - how does fetch work?
      - inside of useEffect

- look innetwork to see request
- look at lecture for TopicList.jsx help and useeffect
- unique key 
- dont use key=index use id ex topic.id
- bad practice to use index remove it from project and use unique key 

- for project can use fetch or Axios 


## Photolabs project
### Instructions
- start psql ```sudo service postgresql start```
```psql -U labber -d photolabs_development```
- in backend
- npm start

- npm run start in backend and frontend
http://localhost:8001/api/photos
http://localhost:8001/api/topics
http://localhost:8001/api/topics/photos/:id :id is 1 or 2 or 3


## Testing in react

- 4 categories
  - static
  - unit
  - integration
  - end to end

## Lecture Feb 18 Automated testing in react
- using CRA instead of VITE 
- if using vite have to use vitest

## React Testing Library
- Unit test broken into 3 phases
  1. Initialize the component that we want to test
  2. Trigger the change that executes the unit
  3. Verify that the unit produced the expected result

  - test render
```js
    it("renders without crashing", () => {
      render(<Button />);
    });
```
- Stored in ```__tests__``` and has ```.test.js``` at the end 

```js
it("renders its `children` prop as text", () => {
  const { getByText } = render(<Button>Default</Button>);
  expect(getByText("Default")).toBeInTheDocument();
});
```
- render function imported from react-testing-library
- expect function injected into glocal scope by Jest
- getByText query function returned by render function but is part of dom-testing-library
- toBeInDocument function is a matcher provided by Jest in jest-dom library

- Jest
  - Common matchers
    - toBe
    - toHaveLength
    - toHaveProperty
    - toBeGreaterThan

- jest-dom
  - dom specific matchers
  - library is the source of toBeInDocument matcher
  - toHaveClass and toHaveValue

- dom-testing-library
  - query is combination of a query variant and a query type
  - getByText
    - variant is getBy
    - type is ByText
  - Access functions by destructuring the object returned by the render function in react-testing-library  

- Test Design
  - 3 phases
    - setup
    - change
    - verify
  - can use expect function a few times in the same test to verify more than one behaviour within a single test

- xit and test.skip
  - to skip test
```js
xit("does something it is supposed to do", () => {
  // ...
});

// or if using test
test.skip("does something it is supposed to do", () => {
  // ...
});
```

- JEST commands watch mode
  - npm test -- --watch
  - Watch Usage

Press a to run all tests.
Press f to run only failed tests.
Press q to quit watch mode.
Press p to filter by a filename regex pattern.
Press t to filter by a test name regex pattern.
Press Enter to trigger a test run.

- Mock functions can be used to track calls to the function, check the arguments it was called with, and even dictate what value it should return.

### Lecture End to End testing with cypress
- static testing is eslint
- cypress is end to end framework for web test automation in Javascript 

## Lecture Real World React
- React Router
- Material UI - free, styled component

## Lecture - Concluding React
- Building Components
- Props
- Fetching Data from an API
- Immutable Patterns

- jsx converted to js using babel compiler
- react app return jsx

## Ruby
- Class based OOP 
- No event loop - Callbacks and Promises are not used
- Version Control/Management 'rbenv'

# Ruby
- Ruby has gems like node has package manager

- hashs are objects but they use keys in ruby
- everything is an object
- no c style loop they have their own methods and functions
- functions parenthesis are optional
- multi line print out use puts
- puts in place of console.log

- callbacks are blocks
- arrow functions are lambdas

### Ruby Cheatsheet
  - https://github.com/ThibaultJanBeyer/cheatsheets/blob/master/Ruby-Cheatsheet.md
  - https://dev.to/ericchapman/my-beloved-ruby-cheat-sheet-208o

### Functions
- Functions do three things:

  - They name pieces of code the way variables name strings and numbers.
  - They take arguments the way your scripts take ARGV.
  - Using 1 and 2 they let you make your own "mini-scripts" or "tiny commands."

- Functions in Ruby

  - Create a function by using the word ```def``` in Ruby

  - *args (asterisk args) which is a lot like your argv parameter but for functions.

  - The variables in your function are not connected to the variables in your script

- Function Checklist Ruby
  - Did you start your function definition with def?
  - Does your function name have only characters and _ (underscore) characters?
  - Did you put an open parenthesis ( right after the function name?
  - Did you put your arguments after the parenthesis ( separated by commas?
  - Did you make each argument unique (meaning no duplicated names)?
  - Did you put a close parenthesis ) after the arguments?
  - Did you indent all lines of code you want in the function two spaces?
  - Did you end your function with end lined up with the def above?


- When you run ("use" or "call") a function, check these things:

  - Did you call/use/run this function by typing its name?
  - Did you put the ( character after the name to run it?
  - Did you put the values you want into the parenthesis separated by commas?
  - Did you end the function call with a ) character?
  - Functions that don't have parameters do not need the () after them, but would it be clearer if you wrote them anyway?

### Boolean Logic Statements
  - solve them easily by this process:

    - Find an equality test (== or !=) and replace it with its truth.
    - Find each &&/|| inside parentheses and solve those first.
    - Find each ! and invert it.
    - Find any remaining &&/|| and solve it.
    - When you are done you should have true or false.

  -  Shortcut: Any && expression that has a false is immediately false, so you can stop there. Any || expression that has a true is immediately true, so you can stop there. But make sure that you can process the whole expression because later it becomes helpful.

- REPL
  - irb is Ruby's command line REPL (read-eval-print-loop) much like how node is JavaScript's. All language REPLs work roughly the same way:

  - Read: A user is prompted to input Ruby expression like 5 + 4, "apples".reverse, etc.
  - Evaluate: After the user hits enter, the REPL evaluates the expression.
  - Print: The REPL prints out what the expression evaluates to, e.g., 5 + 4 evaluates to 9.
  - Loop: We return to the first step, where the user is prompted to input a Ruby expression.

### Blocks and Yield in Ruby
  - In Ruby, methods can receive a code block in order to perform arbitrary segments of code.
  - When a method expects a block, you can invoke it by calling the yield function.
  - Blocks are similar to methods (functions)
  - If arguments are how we pass in data to methods, blocks are how we pass in behavior
  - In Ruby, blocks can be passed into methods as a sort of "invisible argument,"
  - blocks have access to variables outside of their definition

  - Passing a block into a Ruby mehtod is like passing a callback function into javascript function 

- Constants
  - Math.class # => Module
  - Math::PI.class # => Float

  - Both Module and Class constants create a namespace within which other constants can be placed. This type of nesting can be limitless.

  - In Ruby, when you require a library, it typically defines constants directly in the global namespace. On the other hand, JavaScript allows you to assign the exports of a required module to a variable, which controls the scope of where these items are accessible.

- OOP in Ruby
  - without OOP one small change at any point in the program would trigger a ripple effect of errors due to dependencies throughout the entire program.
  - created containers for data that could be changed and manipulated without affecting the entire program

- Encapsulation
  - describes the idea of bundling or combining the data and the operations that work on that data into a single entity - eg. an object
  - also hides functionality to make it unavailable to the rest of the code base - form of data protection
  - the principle of combining data and the operations relevant to that data encapsulation
    - bundle state (data) and behaviour (operations) to form an object

- Polymorphism
  - ability for different types of data to respond to a common interface

- Inheritance
  - class acquires behaviours of another class (reffered to as a superclass)

### Objects in Ruby
  - anything that can be said to have a value is an object
    - numbers, strings, arrays, classes, modules
    - not objects: methods, blocks, and variables
  - objects are made from classes

- Classes define objects
  - ruby defines the attributes and bahaviours of its objects in classes

- workflow of creating a new object or instance from a class is called instantiation

- module is a collection of behaviors that is usable in other classes via mixins
  - a module is 'mixed in' to a class using the include method invocation 

- can use the ancestors method on any class to find out the method lookup chain.

- Create an object in Ruby
  - define a class and instantiate it by using the ```.new``` method to create an instance (method)

- States and Behaviours
  - state referes to the data associated to an individual object
  - behaviours are what objects are capable of doing


- instance variables hold references to other objects enabling the container class to access and interact with the contained objects methods and properties

- Initalizing a new object
```rb
class GoodDog
  def initialize
    puts "This object was initialized!"
  end
end

sparky = GoodDog.new        # => "This object was initialized!"
```

### Instance Variable
  - @ symbol in front
  - variable that exists as long as the object instance exists and it is one of the ways we die data to objects
  - By removing the @ symbol, we're now calling the instance method, rather than the instance variable.
  - you could do this but its generally a good idea to call the getter method instead

  - instance variables have @ (often called attribute)


- In OOP languages, composition and aggregation are design principles used to establish relationships between classes.

- Composition: container contains one or more objects of other classes as part of its state

- Aggregation
  - form of association less tightly coupled than composition
  - lifetime of the contained objects does not depend on the lifetime of the container
  - container can reference the object, and it can coordinate their operations but they exist independently of the container

- attr_accessor method
  - ruby's built in way to automatically create setter and getter methods
  - if we only want getter without setting use attr_reader
  - only setter use attr_writer

- Calling methods with Self
  - setter mehod could not work because Ruby thinks we are initalizing local variables
  - self.name tells Ruby were calling a method
  - avoid self where not required

  - use self when calling setter methods from within the class
  - use self for class method definitions


  - from within a class:
    - self, inside of an instance method references the instance (object) that called the method - the calling object
    - self, outside of an instance method, references the class and can be used to define class methods

  - self is a way of being explicit about what our program is referencing and what our intentions are as far as behavior

 ### Class Methods
  - class level methods
  - methods we can call directly on the class itsself, without having to instantiate any objects
  - prepend the method name with self

```rb
  def self.what_am_i         # Class method definition
    "I'm a GoodDog class!"
  end
  ```

- class variables are created using two @@

- constants
  - when creating classes you might want to change variables
  - create constant
  - define by using upper case at begining of variable name
    - whole variable can be upper case

- to_s Method
  - puts method automatically calls to_s on its arugments
  - puts sparky is equivalent to puts sparky.to_s
  - calls to_s for any argument that is not an array
  - p sparky is equivalent to puts sparky.inspect.
  - Ruby expects #to_s to always return a string (overriding #to_s)

## Class Inheritance
  - < symbol to indicate inheritance
    - all of the methods in that class are available to the other class for use
  - super keyword
    - call methods earlier in the method lookup path
    - use super to invoke the speak method from the superclass

  ### Modules
  - Inheritance vs Modules
    - interface inheritance: class doesnt inherit from another type but instead inherits the interface provided by the mixin module

  - you can onlu subclass (class inheritance) from one class. you can mix in as many modules as you would like.

  - is-a relationship
  - has-a relationship

  - objects cannot be created from modules (cant instantiate)



 ### Namespacing in Ruby
 - organizing similar classes under a module
  - use modules to group related classes
  - call classes in a module by appending the class name to the module name with two colons(::)

  - second use case for modules
    - using modules as a container for methods, called module methods

  - Namespacing is a way of bundling logically related objects together
    - modules is the tool for this
    - classes or modules with conflicting names can co exist while avoiding collisions
    - can think of it as storing different files with the same names under separate directories



  ### Access Control
  - implemented through use of access modifiers
    - allows or restricts access to a particular thing
    - in ruby allow or restrict access to methods defined in a class
  - public, private and protected access modifiers
    - public: available to anyone who know the class or object name
    - private: methods that are doing work in a class but dont need to be available to the rest of the program
    - private: only available to other methods in the class
      - can call private methods with self (inside class)
      - not accessible outside of the class definition at all, and are only access from inside the class when called without self
    - protected: similar to private, cant be invoked outside the class
      - difference protected methods allow access between class instances. private does not

  - Accidental Method Overriding
    - through inheritance, a subclass can override a superclass' method

## Active Record
  - developed as part of rails with purpose of defining database models to allow web app to work easily with a SQL database using Classes
  -  each AR class (Model) corresponds to existing table in database
    - provides attributes that map to each column/field in the table
    - we can CRUD records in table using Class and its instances

## Database Migrations
  - journaling system for database changes
  - bd migrate folder
  - each time you create a migration it is timestamped
  - ```bin/rails db:migrate```
  - db:rollback to go back one migration

# Rails

- Starting Rails Server
  - ```bin/rails server```


### Create database model
- Active Record is a feature of Rails that maps relational databases to Ruby code.
  - SQLite is default for Rails
- Command to generate model
```rb
bin/rails generate model Product name:string
```
- Migrations: set of changes we want to make to database
  - run ```bin/rails db:rollback``` to undo the last migration.

### Parts of a URL
http://example.org/products?sale=true&sort=asc

In this URL, each part has a name:

- https is the protocol
- example.org is the host
- /products is the path
- ?sale=true&sort=asc are the query parameters

### Model View Controller MVC
- architectural pattern adopted to build modern web apps
  - separates data in app and code used to display it
- M is active record
- when app has directory called app/ with subdirectories called models views and controllers, this is a hint it follows MVC pattern

- Benefits of MVC
  - The MVC architecture in Rails provides several benefits for maintenance and development:

  - Separation of Concerns: By dividing the application into models, views, and controllers, Rails allows developers to work on separate aspects of the application independently. This separation helps in organizing the code better, making it easier to manage and reducing the chances of conflicts between code handling the business logic and the presentation layer.
  - Reusability: Components in Rails, especially models and views, can be reused across different parts of the application. For example, the same User model can be used to handle data for both user profiles and user authentication.
  - Scalability: MVC supports scalability. As the application grows, developers can focus on scaling individual aspects of the application (like optimizing database queries in models) without affecting the entire architecture.
  - Ease of Testing: MVC facilitates testing since each component can be tested independently. For example, models can be tested separately from views and controllers.

- when interacting with rails app, browser sends request, recieved by web server, and passed to rails controller
  - commonly the controller interacts with a model (ruby object) and is in charge of communicating with the database

- Summary of steps:
  - The browser issues a request for the /users URL.
  - Rails routes /users to the index action in the Users controller.
  - The index action asks the User model to retrieve all users (User.all).
  - The User model pulls all the users from the database.
  - The User model returns the list of users to the controller.
  - The controller captures the users in the @users variable, which is passed to the index view.
  - The view uses embedded Ruby to render the page as HTML.
  - The controller passes the HTML back to the browser.

  - The browser issues a request for the /users/:id URL.
  - Rails routes /users/:id to the show action in the Users controller.
  - The show action asks the User model to retrieve a specific user (User.find(params[:id])).
  - The User model pulls the specific user from the database.
  - The User model returns the user to the controller.
  - The controller captures the user in the @user variable, which is passed to the show view.
  - The view uses embedded Ruby to render the page as HTML, including the user's data.
  - The controller passes the HTML back to the browser.

- controller contains a collection of related actions







# Project Planning Lecture
- wont be given boilerplate
  -  can use react / rails
  - can use free resources
  - "plans are worthless but planning is everything"

- can use other tech
  - one time someone made chrome extension ( react native)
  - swift UI to build IOS apps
  - someone made a crypto currency
  - android dev studio
  - react native / flutter for ios and andriod apps

- Figure out tech stack first
  - only modify tech stack while planning

  - figure out font size colors background colors

  - Figma




## Jungle Rails Project

- Instructions to start
  - PSQL
    - sudo service postgresql start
    - psql -U development -d jungle_development
  - start server 
    - bin/rails s -b 0.0.0.0
  - check routes
    - bin/rails routes
  - reset database
    - bin/rails db:reset

- Versions:
  - ruby 3.1.1 - no other versions on pc
  - rails 7.1
  - changed gem puma to 6.0

BUNDLE_GEMFILE=~/lighthouse/Jungle-Rails/Gemfile bundle install


- For Ruby/ Rails installing and pointing to gemfile
bundle install --gemfile=./Gemfile

sudo service postgresql start
 peter heyboer lighthouse
psql -U development -d 

bundle install --gemfile=/home/peterheyboer/lighthouse/Jungle-Rails/Gemfile


- use ruby 3.1.1 
- use rails '6.1.5.1
- start psql
- uncomment username/password in database.yml
- reset database
- was the conflict rails 7.2?
- problems: couldnt find gemfile

sudo service postgresql start

psql -U development -d jungle_development
pass development

- start server 
bin/rails s -b 0.0.0.0

- have 2 terminals open 1 for server

The bin/rails db:setup command, which in turn calls the bin/rails db:schema:load command, uses this schema.rb

- might need gem update
gem update --system 3.3.22
gem install bundler:2.6.5
bundle install (worked) inside project 


- start server 
bin/rails s -b 0.0.0.0

to check routes
bin/rails routes

- Rails MVC
  - routes.db

- ERB
  - embedded ruby - templating system allows you to embed ruby code inside HTML
  - commonly used in Rails views (.html.erb) to dynamically generate HTML content

## Lecture Advanced Topics - Typescript

- Javascript written in 15 days not the best
- Typescript 
- Dx developer experience

- superset of javascript
  - built by microsoft
  - javascript is not a compiled language
  -runtime
  - interpreter

  -complied langues c++

- type script is not a languge 
  - adds a syntax ontop of javascript that makes life easier
- complies to readable JS

statically typed language - have to provide all the variables

types

- automatic code completion

npm install typescript --save-dev
  - dev dependecny - not sent to user, javacsript is sent

Types:
  - primitive value types
  - explicit
  - implicit
  - literal


- React and typescript
  - .tsx file

- generix (advanced) 


- Order Args
  - object order
  - sending props in typescript

### Rails Overview Lecture March 18
- Learning about Rails and Terminal commands

- React is CSR - client side
- Rails is SSR - server side

- MVC - slower than virtual DOM

- displaying how to use the terminal/command line 
- Bryan is using rails 7.2.2.1 in lecture
- create new app: ```rails new App-Name --database=postgresql```
- SQL is default
- if you dont have database run ```rails db:create```
- ```rails generate model```
- rails is intuitive so you dont need to make ERD with relationships
- ```rails db:migrate```
  - combines everything is migrate folder and populates schema
- gem for rails to mock information - faker gem - if you need data to 
- ```rails generate controller```

- ```rails routes``` to generate all routes in app

- model controller view path

## Advanced State management in React Lecture - March 20
- useReducer took over Redux for state management
- tailwind to make the app look good in the demo


- React Context: dont use it for things that change very often
- Global Stores:
- cant use prop drilling with thousands of components (big projects/apps)
  - global stores -  single source of truth that all components can access.
  - need global stores when:
    - multiple components need access to same data (authentication, user settings, themes)
    - complex state that changes frequently
    - when passing props becomes too difficult
  - context - state provider.jsx
  - import createContext

  - steps
    - create the context
    - create provider component
    - define values in the state provider using the value prop
    - wrap your app with provider
    - use global state to access states in components
    - 
- zustand
  - 

- state management
  - redux
  - mobx
  - react query
  - zustand
  - recoil
  - jotai
  - valtio
  - apollo client


## Final Project - Ideas
- keep main idea simple, and build on/ add features

- Gamified budget tracker
  - virtual currency - crypto?
  - challenges/missions
  - ai budget assisstant
  - real life discounts

- Accessibility app
  - Skill swap?
    - Features: Profile system, skill matching, messaging, scheduling.

- Gamified Habit Tracker
  - turn daily habits into games
  - this is like finch mental health app

- AI powered code debugger
  - like phyton tutor 

## Blog Post Peer Reviewd - Research and Reflect
